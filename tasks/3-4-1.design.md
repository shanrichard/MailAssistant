# Design 3-4-1 - 实现前端错误收集器

## Requirements

实现一个轻量级的前端错误收集器，将错误信息存储在 localStorage 中，供开发调试使用。

### 需求细节

1. **错误捕获**
   - 拦截 console.error 调用
   - 捕获未处理的 Promise rejection
   - 记录错误发生的时间、消息、堆栈信息

2. **localStorage 存储**
   - 使用固定的 key：`mailassistant_frontend_errors`
   - 存储最近 100 条错误（循环覆盖）
   - 每条错误包含：时间戳、错误类型、消息、堆栈、URL

3. **开发环境控制**
   - 只在开发环境启用（通过环境变量控制）
   - 不影响生产环境性能

## Solution

### 技术方案

#### 1. 错误收集器实现

```typescript
// frontend/src/utils/errorCollector.ts
class ErrorCollector {
  private readonly STORAGE_KEY = 'mailassistant_frontend_errors';
  private readonly MAX_ERRORS = 100;
  private isEnabled: boolean;

  constructor() {
    // 只在开发环境启用
    this.isEnabled = process.env.NODE_ENV === 'development';
    if (this.isEnabled) {
      this.setupErrorHandlers();
    }
  }

  private setupErrorHandlers() {
    // 拦截 console.error
    const originalError = console.error;
    console.error = (...args) => {
      this.logError({
        type: 'console.error',
        message: args.map(arg => 
          typeof arg === 'object' ? JSON.stringify(arg) : String(arg)
        ).join(' '),
        timestamp: new Date().toISOString(),
        url: window.location.href
      });
      originalError.apply(console, args);
    };

    // 捕获未处理的 Promise rejection
    window.addEventListener('unhandledrejection', (event) => {
      this.logError({
        type: 'unhandledRejection',
        message: event.reason?.message || String(event.reason),
        stack: event.reason?.stack,
        timestamp: new Date().toISOString(),
        url: window.location.href
      });
    });
  }

  private logError(error: ErrorLog) {
    if (!this.isEnabled) return;

    try {
      // 获取现有错误
      const existingErrors = this.getErrors();
      
      // 添加新错误到开头
      existingErrors.unshift(error);
      
      // 保留最近的 MAX_ERRORS 条
      const errorsToSave = existingErrors.slice(0, this.MAX_ERRORS);
      
      // 存储到 localStorage
      localStorage.setItem(this.STORAGE_KEY, JSON.stringify(errorsToSave));
    } catch (e) {
      // localStorage 可能已满，忽略错误
    }
  }

  private getErrors(): ErrorLog[] {
    try {
      const stored = localStorage.getItem(this.STORAGE_KEY);
      return stored ? JSON.parse(stored) : [];
    } catch {
      return [];
    }
  }

  // 供测试使用的公共方法
  public clearErrors() {
    localStorage.removeItem(this.STORAGE_KEY);
  }

  public getAllErrors(): ErrorLog[] {
    return this.getErrors();
  }
}

// 错误日志类型定义
interface ErrorLog {
  type: 'console.error' | 'unhandledRejection';
  message: string;
  stack?: string;
  timestamp: string;
  url: string;
}

// 导出单例
export const errorCollector = new ErrorCollector();
```

#### 2. 集成到应用入口

```typescript
// frontend/src/index.tsx
import { errorCollector } from './utils/errorCollector';

// 在应用启动时初始化（构造函数会自动设置错误处理器）
// errorCollector 已经是单例，无需额外操作

// 原有的应用启动代码...
```

#### 3. React ErrorBoundary 集成（可选）

```typescript
// frontend/src/components/ErrorBoundary.tsx
import React from 'react';
import { errorCollector } from '../utils/errorCollector';

class ErrorBoundary extends React.Component<
  { children: React.ReactNode },
  { hasError: boolean }
> {
  constructor(props: { children: React.ReactNode }) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError() {
    return { hasError: true };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    // 手动记录到 errorCollector
    console.error('React Error:', error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return <h1>Something went wrong.</h1>;
    }

    return this.props.children;
  }
}

export default ErrorBoundary;
```

### 实施步骤

1. 创建 `errorCollector.ts` 文件
2. 在 `index.tsx` 中导入（自动初始化）
3. 可选：在 App.tsx 中包裹 ErrorBoundary
4. 测试各种错误场景


## Tests

- [ ] console.error 被正确拦截并存储
- [ ] Promise rejection 被捕获
- [ ] localStorage 中最多保存 100 条错误
- [ ] 生产环境不会启用错误收集
- [ ] 错误信息格式正确且完整