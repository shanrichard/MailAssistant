# Design 3-21 - 日报系统架构优化

## Requirements

### 核心需求
1. **前端简化**：不需要结构化文本，直接展示Markdown格式的纯文本
2. **持久化存储**：Agent生成的日报需要存储到 DailyReportLog 表
3. **状态管理**：正确处理 processing、completed、failed 状态
4. **数据新鲜度**：确保生成日报时邮件数据是最新的
5. **用户体验**：提供日报刷新功能，支持覆盖当天旧日报

### EmailProcessorAgent 定位
- **专项Agent**：只负责生成日报功能
- **固定输入**：`"请生成今天的邮件日报"`
- **固定输出**：Markdown格式的日报内容
- 不需要判断用户意图

## Solution

### 1. 日报生成流程

```
前端请求 GET /api/reports/daily
    ↓
检查邮件同步时间
    ↓ (超过30分钟)
触发后台邮件同步（不等待）
    ↓
检查 DailyReportLog
    ↓
情况1: 存在且status='completed' → 返回日报内容
情况2: 存在且status='processing' → 返回"生成中"状态
情况3: 不存在或status='failed' → 创建processing记录 → 异步触发Agent生成
```

### 实现架构

#### 1.1 新建 reports.py 路由模块
- 位置：`backend/app/api/reports.py`
- 包含 GET /api/reports/daily 和 POST /api/reports/daily/refresh
- 注册到 main.py 中

### 2. API设计

#### 2.1 GET /api/reports/daily
获取今日日报，响应格式：
```json
// 情况1: 日报已存在且完成
{
  "status": "completed",
  "content": "# 2024年1月25日 邮件日报\n\n...",  // Markdown内容
  "generated_at": "2024-01-25T10:30:00Z"
}

// 情况2: 日报正在生成中（已有processing记录）
{
  "status": "processing",
  "message": "日报生成中，请稍后刷新页面"
}

// 情况3: 首次生成（刚创建processing记录并触发生成）
{
  "status": "processing",
  "message": "开始生成日报，请稍后刷新页面"
}
```

#### 2.2 POST /api/reports/daily/refresh
强制刷新日报：
- 删除当天旧日报
- 触发重新生成
- 返回processing状态

### 3. 触发式邮件同步

由于Socket.IO集成导致FastAPI的BackgroundTasks不可用，需要使用asyncio.create_task：

```python
async def check_and_trigger_sync(user_id: str, db: Session):
    """检查并触发邮件同步"""
    from datetime import datetime, timedelta, timezone
    from ..models.user import User
    from ..services.email_sync_service import email_sync_service
    
    user = db.query(User).filter(User.id == user_id).first()
    
    # 使用 last_history_sync 字段判断
    if not user.last_history_sync or \
       datetime.now(timezone.utc) - user.last_history_sync > timedelta(minutes=30):
        # 使用 asyncio.create_task 触发后台同步，不等待
        asyncio.create_task(sync_user_emails_task(user_id))
        logger.info(f"Triggered background email sync for user {user_id}")

async def sync_user_emails_task(user_id: str):
    """后台同步任务"""
    try:
        # 创建新的数据库会话
        db = SessionLocal()
        user = db.query(User).filter(User.id == user_id).first()
        if user:
            # 调用现有的同步服务
            email_sync_service.sync_user_emails(db, user)
    except Exception as e:
        logger.error(f"Background sync failed for user {user_id}: {e}")
    finally:
        db.close()
```

### 4. 日报生成任务

同样使用asyncio.create_task处理后台任务：

```python
async def trigger_report_generation(user_id: str, report_date: date):
    """触发日报生成（异步执行）"""
    asyncio.create_task(generate_report_task(user_id, report_date))

async def generate_report_task(user_id: str, report_date: date):
    """后台任务：生成日报"""
    from ..core.database import SessionLocal
    from ..agents.email_processor import EmailProcessorAgent
    from ..models.daily_report_log import DailyReportLog
    
    db = SessionLocal()
    try:
        # 1. 创建Agent实例
        processor = EmailProcessorAgent(str(user_id), db)
        
        # 2. 固定的请求消息
        report_content = await processor.process("请生成今天的邮件日报")
        
        # 3. 更新数据库
        report = db.query(DailyReportLog).filter(
            DailyReportLog.user_id == user_id,
            DailyReportLog.report_date == report_date
        ).first()
        
        if report:
            report.status = 'completed'
            report.report_content = {'content': report_content}
            report.updated_at = datetime.now(timezone.utc)
            db.commit()
            logger.info(f"Report generated for user {user_id} on {report_date}")
            
    except Exception as e:
        logger.error(f"Failed to generate report: {e}")
        # 更新状态为failed
        report = db.query(DailyReportLog).filter(
            DailyReportLog.user_id == user_id,
            DailyReportLog.report_date == report_date
        ).first()
        if report:
            report.status = 'failed'
            report.report_content = {'error': str(e)}
            db.commit()
    finally:
        db.close()
```

### 5. 前端改造

#### 5.1 数据结构简化

前端需要从期望结构化数据改为处理纯Markdown：

```typescript
// 新的响应格式（与后端API一致）
interface DailyReportResponse {
  status: 'completed' | 'processing' | 'failed';
  content?: string;      // Markdown内容
  message?: string;      // 状态消息
  generated_at?: string; // ISO时间字符串
}

// 需要删除旧的结构化类型定义
// 删除：DailyReport, DailyReportStats, ImportantEmail, EmailCategory等
```

#### 5.2 Markdown渲染
- 使用 `react-markdown` 库
- 支持代码高亮、表格等扩展
- 自定义样式以匹配应用主题

#### 5.3 状态处理
- processing状态：显示加载动画和提示信息
- 提供手动刷新按钮
- 不使用自动轮询

### 6. 并发控制

```python
# 在 GET /api/reports/daily 中的并发处理
try:
    new_report = DailyReportLog(
        user_id=user_id,
        report_date=today,
        status='processing',
        report_content={}
    )
    db.add(new_report)
    db.commit()
    
    # 成功创建，触发生成
    await trigger_report_generation(user_id, today)
    
    return {
        'status': 'processing',
        'message': '开始生成日报，请稍后刷新页面'
    }
    
except IntegrityError:
    # 已存在，说明其他请求已经在处理
    db.rollback()
    existing = db.query(DailyReportLog).filter(
        DailyReportLog.user_id == user_id,
        DailyReportLog.report_date == today
    ).first()
    
    if existing.status == 'processing':
        return {
            'status': 'processing',
            'message': '日报生成中，请稍后刷新页面'
        }
    # ... 处理其他状态
```

### 7. 超时处理

- processing状态超过5分钟视为超时
- 超时后将状态改为failed
- 可选：自动重新触发生成

## Tests

### 1. API测试 (test_reports_api.py)
```python
# 测试首次访问生成日报
def test_get_daily_report_first_time():
    """首次访问应创建processing记录并触发生成"""
    response = client.get("/api/reports/daily")
    assert response.status_code == 200
    assert response.json()["status"] == "processing"
    assert "开始生成日报" in response.json()["message"]

# 测试获取已存在的日报
def test_get_existing_daily_report():
    """获取已完成的日报"""
    # 先在数据库中创建一个completed状态的日报
    response = client.get("/api/reports/daily")
    assert response.status_code == 200
    assert response.json()["status"] == "completed"
    assert "content" in response.json()

# 测试并发请求处理
def test_concurrent_report_requests():
    """并发请求应只触发一次生成"""
    # 使用 threading 模拟并发请求
    # 验证只有一个processing记录被创建

# 测试刷新功能
def test_refresh_daily_report():
    """刷新应删除旧日报并重新生成"""
    response = client.post("/api/reports/daily/refresh")
    assert response.status_code == 200
    assert response.json()["status"] == "processing"
```

### 2. 同步机制测试 (test_sync_trigger.py)
```python
# 验证30分钟触发逻辑
def test_sync_trigger_after_30_minutes():
    """超过30分钟应触发同步"""
    # 修改用户的 last_history_sync 为31分钟前
    # 调用 check_and_trigger_sync
    # 验证 background_tasks 被调用

# 验证后台同步不阻塞
def test_sync_non_blocking():
    """同步应在后台执行，不阻塞响应"""
    # 测试响应时间小于1秒
    # 验证同步任务被添加到后台
```

### 3. 前端测试 (DailyReport.test.tsx)
```typescript
// Markdown渲染测试
test('renders markdown content correctly', () => {
  const mockReport = {
    status: 'completed',
    content: '# 日报标题\n\n- 列表项1\n- 列表项2'
  };
  render(<DailyReport />);
  expect(screen.getByText('日报标题')).toBeInTheDocument();
});

// 状态切换测试
test('shows loading state while processing', () => {
  const mockReport = { status: 'processing' };
  render(<DailyReport />);
  expect(screen.getByText(/生成中/)).toBeInTheDocument();
});

// 错误处理测试
test('shows error message on failure', () => {
  const mockReport = { status: 'failed', message: '生成失败' };
  render(<DailyReport />);
  expect(screen.getByText(/生成失败/)).toBeInTheDocument();
});
```

### 4. Agent测试 (test_email_processor_report.py)
```python
# 验证固定输入输出
async def test_agent_daily_report_generation():
    """Agent应正确生成Markdown格式日报"""
    agent = EmailProcessorAgent(user_id, db)
    result = await agent.process("请生成今天的邮件日报")
    assert isinstance(result, str)
    assert result.startswith("#")  # Markdown标题
    assert "邮件" in result

# 验证错误处理
async def test_agent_error_handling():
    """Agent错误应被正确处理"""
    # 模拟数据库连接失败等错误
    # 验证返回合适的错误信息
```

## 实施顺序

1. **3-21-1**: 实现基础的 GET /api/reports/daily
   - 创建 reports.py 路由文件
   - 处理三种状态返回
   - 使用 asyncio.create_task 替代 BackgroundTasks
   - 集成 EmailProcessorAgent 生成日报

2. **3-21-2**: 添加触发式同步机制
   - 在 API 中添加同步检查
   - 实现非阻塞的后台同步
   - 更新用户的 last_history_sync 时间戳

3. **3-21-3**: 前端Markdown渲染改造
   - 安装 react-markdown 依赖
   - 重写 DailyReport.tsx 组件
   - 删除结构化数据组件
   - 更新类型定义

4. **3-21-4**: 实现刷新功能
   - 添加 POST /api/reports/daily/refresh
   - 前端添加刷新按钮
   - 处理删除和重新生成逻辑

5. **3-21-5**: 优化并发和超时处理
   - 完善并发控制逻辑
   - 添加超时检查
   - 编写测试用例

## 关键技术点

1. **BackgroundTasks替代方案**：由于Socket.IO集成，使用 `asyncio.create_task`
2. **数据库会话管理**：后台任务需要创建独立的数据库会话
3. **前端数据格式转换**：从结构化数据到纯Markdown文本
4. **并发控制**：利用数据库唯一约束防止重复生成

## 与现有代码的关键差异

1. **异步任务处理**
   - 不能使用 FastAPI 的 BackgroundTasks（Socket.IO集成导致失效）
   - 使用 `asyncio.create_task` 启动后台任务
   - 后台任务需要创建独立的数据库会话（SessionLocal）

2. **EmailProcessorAgent调用**
   - Agent已有完整的日报生成prompt（在agent_prompts.py中）
   - 调用方式：`await processor.process("请生成今天的邮件日报")`
   - 返回Markdown格式的文本内容

3. **同步服务调用**
   - 现有的 `email_sync_service.sync_user_emails` 是同步函数
   - 需要在异步上下文中调用（但不会阻塞）
   - 需要传入User对象而非user_id

4. **前端改造范围**
   - 需要完全重写DailyReport组件
   - 删除所有结构化数据处理逻辑
   - 新增Markdown渲染功能