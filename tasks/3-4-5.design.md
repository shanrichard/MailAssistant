# Design 3-4-5 - 完善日志系统持久化和查询功能

## Requirements

- 前端发送的错误日志需要在后端持久化存储
- 后端需要配置正确的日志文件路径
- 提供更完善的错误查询和过滤功能
- 支持错误统计和分析
- 确保前后端错误都能被正确收集和展示

## Solution

### 1. 前端错误持久化存储（轻量方案）

#### 1.1 写入日志文件
前端错误和后端错误统一写入日志文件，使用相同的格式：

```python
# 修改 /api/debug/logs/all 端点
@router.post("/all")
async def get_all_logs(request: Request):
    """接收前端错误并写入日志文件"""
    check_dev_environment()
    
    body = await request.json()
    frontend_errors = body.get("frontend_errors", [])
    
    # 将前端错误写入日志文件
    for error in frontend_errors:
        logger.error(
            "Frontend error",
            extra={
                "source": "frontend",
                "error_type": error.get("type"),
                "message": error.get("message"),
                "stack": error.get("stack"),
                "url": error.get("url"),
                "user_agent": request.headers.get("User-Agent"),
                "timestamp": error.get("timestamp")
            }
        )
    
    # 返回所有日志（包括刚写入的）
    return await get_all_logs_from_file()
```

### 2. 后端日志系统改进

#### 2.1 配置日志文件路径
在 `backend/app/core/config.py` 中添加日志配置：

```python
# 日志配置
LOG_DIR = "logs"
LOG_FILE = "app.log"
LOG_MAX_SIZE = 10 * 1024 * 1024  # 10MB
LOG_BACKUP_COUNT = 5
```

#### 2.2 统一日志格式
使用 Python 的 logging 模块配置 JSON 格式日志：

```python
import logging
import json
from pythonjsonlogger import jsonlogger

# 配置日志格式
logHandler = logging.handlers.RotatingFileHandler(
    filename=os.path.join(LOG_DIR, LOG_FILE),
    maxBytes=LOG_MAX_SIZE,
    backupCount=LOG_BACKUP_COUNT
)
formatter = jsonlogger.JsonFormatter()
logHandler.setFormatter(formatter)
logger = logging.getLogger()
logger.addHandler(logHandler)
logger.setLevel(logging.INFO)
```

### 3. 改进日志查询功能

#### 3.1 优化现有查询
改进 `get_backend_errors` 函数，支持查询前后端错误：

```python
async def get_all_errors_from_file(
    limit: int = 200,
    source: Optional[str] = None,  # "frontend" | "backend" | None
    level: Optional[str] = None,
    keyword: Optional[str] = None
) -> List[Dict]:
    """从日志文件读取所有错误（包括前端和后端）"""
    errors = []
    
    # 确保日志目录存在
    os.makedirs(settings.LOG_DIR, exist_ok=True)
    log_file_path = os.path.join(settings.LOG_DIR, settings.LOG_FILE)
    
    if not os.path.exists(log_file_path):
        return []
    
    try:
        with open(log_file_path, 'r', encoding='utf-8') as f:
            # 读取文件的最后部分
            f.seek(0, 2)
            file_size = f.tell()
            read_size = min(file_size, 500 * 1024)  # 读取最后 500KB
            f.seek(max(0, file_size - read_size))
            content = f.read()
            lines = content.splitlines()
            
        for line in reversed(lines):
            if not line.strip():
                continue
                
            try:
                log_entry = json.loads(line)
                
                # 过滤来源
                if source and log_entry.get("source") != source:
                    continue
                
                # 过滤级别
                if level and log_entry.get("levelname", "").lower() != level.lower():
                    continue
                
                # 关键词搜索
                if keyword and keyword.lower() not in str(log_entry).lower():
                    continue
                
                # 构造统一的错误格式
                error_item = {
                    "source": log_entry.get("source", "backend"),
                    "timestamp": log_entry.get("timestamp"),
                    "type": log_entry.get("error_type", "backend_log"),
                    "message": log_entry.get("message"),
                    "level": log_entry.get("levelname", "").lower(),
                    "stack": log_entry.get("stack"),
                    "url": log_entry.get("url"),
                    "user_agent": log_entry.get("user_agent")
                }
                
                errors.append(error_item)
                
                if len(errors) >= limit:
                    break
                    
            except json.JSONDecodeError:
                continue
                
    except Exception as e:
        logger.error(f"Failed to read log file: {str(e)}")
    
    return errors
```

### 4. 前端调整（可选）

#### 4.1 保留发送记录
如果需要知道哪些错误已经发送过，可以稍作修改：

```typescript
// 在 errorCollector.ts 中添加发送记录
private async sendToBackend(errors: ErrorLog[]) {
    const response = await axios.post('http://localhost:8000/api/debug/logs/all', {
      frontend_errors: errors
    });
    
    // 可选：记录最后发送时间
    localStorage.setItem(this.STORAGE_KEY + '_last_sent', new Date().toISOString());
    
    // 仍然删除已发送的错误，避免重复发送
    this.removeErrorsFromStorage(errors);
    return response.data;
}
```

### 5. 简化的实施步骤

1. **配置日志系统** - 设置日志文件路径和格式
2. **修改 API 端点** - 接收前端错误并写入日志
3. **改进查询功能** - 支持查询前后端所有错误
4. **测试验证** - 确保错误能正确记录和查询

## Tests

- [ ] 前端错误发送后能在日志文件中查询到
- [ ] 后端日志文件正确配置并能写入
- [ ] 日志文件包含前后端错误，格式统一
- [ ] 查询功能支持按来源（frontend/backend）过滤
- [ ] 查询功能支持关键词搜索
- [ ] 日志文件自动轮转功能正常
- [ ] 仅在开发环境启用