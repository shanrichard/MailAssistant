# Design 3-9-6: 实现心跳机制和精确监控

## Requirements
- 实现比超时清理更可靠的活跃度检测机制
- 15秒心跳间隔，30秒超时检测
- 能检测到真正的进程崩溃或网络问题
- 提供优雅的心跳取消和状态释放机制

## Solution
**基于专家建议的心跳监控方案**：

### 1. 带心跳的后台同步执行器
```python
async def execute_background_sync_v2(user_id: str, force_full: bool, task_id: str):
    """带心跳机制的后台同步执行器"""
    from asyncio import create_task, sleep
    from datetime import datetime
    
    HEARTBEAT_INTERVAL = 15  # 心跳间隔15秒
    
    async def heartbeat_worker():
        """心跳工作线程"""
        while True:
            try:
                await sleep(HEARTBEAT_INTERVAL)
                
                # 更新心跳时间戳
                db = SessionLocal()
                try:
                    result = db.execute(
                        update(UserSyncStatus)
                        .where(UserSyncStatus.task_id == task_id)
                        .values(updated_at=datetime.utcnow())
                    )
                    db.commit()
                    
                    if result.rowcount == 0:
                        logger.warning(f"心跳更新失败，任务可能已被清理: {task_id}")
                        break
                        
                except Exception as e:
                    logger.error(f"心跳更新异常: {e}", task_id=task_id)
                finally:
                    db.close()
                    
            except Exception as e:
                logger.error(f"心跳线程异常: {e}", task_id=task_id)
                break

    # 启动心跳任务
    heartbeat_task = create_task(heartbeat_worker())
    
    try:
        # 执行实际的同步逻辑
        await execute_actual_sync(user_id, force_full, task_id)
        
    except Exception as e:
        logger.error(f"同步任务执行失败: {e}", task_id=task_id)
        raise
        
    finally:
        # 确保心跳任务被取消
        heartbeat_task.cancel()
        try:
            await heartbeat_task
        except:
            pass
            
        # 释放同步状态
        release_sync_status_atomic(user_id, task_id)
```

### 2. 实际同步执行逻辑
```python
async def execute_actual_sync(user_id: str, force_full: bool, task_id: str):
    """实际执行同步的核心逻辑"""
    db = SessionLocal()
    try:
        user = db.query(User).filter(User.id == user_id).first()
        if not user:
            raise ValueError(f"用户不存在: {user_id}")
            
        # 定义进度回调
        def progress_callback(progress_info):
            try:
                db.execute(
                    update(UserSyncStatus)
                    .where(UserSyncStatus.task_id == task_id)
                    .values(
                        progress_percentage=progress_info.get('progress_percentage', 0),
                        current_stats=progress_info.get('current_stats', {}),
                        updated_at=datetime.utcnow()
                    )
                )
                db.commit()
            except Exception as e:
                logger.error(f"进度更新失败: {e}", task_id=task_id)
        
        # 执行智能同步
        result = await email_sync_service.smart_sync_user_emails(
            db, user, force_full, progress_callback=progress_callback
        )
        
        # 标记完成
        db.execute(
            update(UserSyncStatus)
            .where(UserSyncStatus.task_id == task_id)
            .values(
                is_syncing=False,
                progress_percentage=100,
                current_stats=result,
                updated_at=datetime.utcnow()
            )
        )
        db.commit()
        
        logger.info(f"同步任务完成", task_id=task_id, stats=result)
        
    except Exception as e:
        # 记录错误但不释放状态（由finally块处理）
        logger.error(f"同步执行异常: {e}", task_id=task_id)
        raise
    finally:
        db.close()
```

### 3. 原子性状态释放
```python
def release_sync_status_atomic(user_id: str, task_id: str, error_message: str = None):
    """原子性释放同步状态"""
    db = SessionLocal()
    try:
        with db.begin():
            updates = {
                'is_syncing': False,
                'updated_at': datetime.utcnow()
            }
            if error_message:
                updates['error_message'] = error_message
                updates['progress_percentage'] = 0  # 错误时重置进度
                
            db.execute(
                update(UserSyncStatus)
                .where(UserSyncStatus.task_id == task_id)
                .values(**updates)
            )
            
    except Exception as e:
        logger.error(f"状态释放失败: {e}", task_id=task_id)
    finally:
        db.close()
```

## Tests
- 模拟同步过程中的心跳更新，验证正常工作
- 测试心跳中断后的检测和清理逻辑
- 验证心跳超时后的任务自动结束
- 测试异常情况下心跳任务的优雅取消

**心跳机制优势**：
- 精确检测：`updated_at` 连续 2×心跳周期（30秒）不更新即可认定僵死
- 比简单超时更可靠：不依赖 `started_at + 30min` 判定
- 实时状态：可以检测到真正的进程崩溃或网络问题
- 自动恢复：心跳失败会自动结束任务