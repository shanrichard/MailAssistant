# Design 2-12-8 - Settings页面实现（框架和功能）

## Requirements
实现一个极简的Settings页面，只包含日报定时设置功能。用户可以设置每日报告自动生成的时间。

**注：原本分为框架（2-12-8）和功能（2-12-14）两步，由于Settings页面功能简单，现合并为一个任务。**

### 功能需求
1. **日报时间设置**
   - 用户可以选择每天几点几分生成日报
   - 时间以用户本地时区为准
   - 设置后立即生效，更新后端定时任务

### 用户体验
- 界面极简，只显示必要的设置项
- 清晰的保存反馈
- 显示当前设置的时间

## Solution

### 界面设计
```typescript
// 页面结构
<Settings>
  <h1>设置</h1>
  <Card>
    <h2>日报生成时间</h2>
    <p>设置每天自动生成邮件日报的时间</p>
    <p className="text-sm text-gray-500">当前时区：{timezone} (本地)</p>
    <TimePicker 
      value={reportTime} 
      format="HH:mm"
      use24Hours={true}
    />
    <Button 
      onClick={save} 
      disabled={loading || saveSuccess}
    >
      {loading ? '保存中...' : saveSuccess ? '已保存' : '保存'}
    </Button>
  </Card>
</Settings>
```

### 技术实现

#### 前端实现

1. **Settings组件**
```typescript
// Settings.tsx
const Settings: React.FC = () => {
  const [reportTime, setReportTime] = useState<string>('09:00');
  const [loading, setLoading] = useState(false);
  const [saveSuccess, setSaveSuccess] = useState(false);
  const [timezone, setTimezone] = useState<string>('');
  
  // 加载当前设置
  useEffect(() => {
    const tz = Intl.DateTimeFormat().resolvedOptions().timeZone;
    setTimezone(tz);
    loadSettings();
  }, []);
  
  // 保存设置
  const handleSave = async () => {
    setLoading(true);
    try {
      await schedulerApi.updateSchedule({ 
        time: reportTime, // HH:mm 格式
        timezone: timezone
      });
      
      // 成功反馈
      showSuccessMessage('设置保存成功');
      setSaveSuccess(true);
      setTimeout(() => setSaveSuccess(false), 2000); // 2秒后恢复按钮
      
    } catch (error: any) {
      // 显示具体错误信息
      const errorMsg = error.response?.data?.detail || '保存失败，请重试';
      showErrorMessage(errorMsg);
    } finally {
      setLoading(false);
    }
  };
  
  // TimePicker组件选择
  // 使用 react-time-picker 或 rc-time-picker
  // 支持24小时格式，返回 HH:mm 字符串
}
```

2. **API客户端**
```typescript
// services/api.ts
export const schedulerApi = {
  getSchedule: () => api.get('/scheduler'), // RESTful语义
  updateSchedule: (data: ScheduleUpdate) => api.put('/scheduler', data), // PUT幂等操作
  triggerDailyReport: () => api.post('/scheduler/trigger/daily_report')
};

// types/index.ts
interface ScheduleUpdate {
  time: string; // HH:mm 格式
  timezone: string; // IANA时区名
}
```

3. **Zustand Store**
```typescript
// stores/settingsStore.ts
interface SettingsState {
  dailyReportTime: string;
  timezone: string;
  loadSettings: () => Promise<void>;
  updateSettings: (settings: Partial<Settings>) => Promise<void>;
}
```

#### 后端实现（使用现有scheduler API）

1. **Scheduler API路由（调整为RESTful）**
```python
# api/scheduler.py
from pydantic import BaseModel, validator
import re

class ScheduleUpdate(BaseModel):
    time: str  # HH:mm 格式
    timezone: str  # IANA时区
    
    @validator('time')
    def validate_time_format(cls, v):
        if not re.match(r'^([01]\d|2[0-3]):[0-5]\d$', v):
            raise ValueError('时间格式必须为 HH:mm')
        return v

@router.get("/")
async def get_schedule(user: User = Depends(get_current_user)):
    # 返回用户的调度设置
    return await task_service.get_user_schedule(user.id)

@router.put("/")  # PUT for idempotent updates
async def update_schedule(
    schedule_update: ScheduleUpdate,
    user: User = Depends(get_current_user)
):
    try:
        # 更新用户的调度设置
        return await task_service.update_user_schedule(user.id, schedule_update)
    except ValueError as e:
        raise HTTPException(status_code=422, detail=str(e))
```

2. **TaskService实现（增强版）**
```python
# services/task_service.py
from datetime import time
import pytz

class TaskService:
    async def update_user_schedule(self, user_id: str, schedule_update: ScheduleUpdate):
        """更新用户调度设置并重新调度任务"""
        # 1. 更新数据库中的用户偏好
        hour, minute = map(int, schedule_update.time.split(':'))
        preferences = await self.update_user_preferences(
            user_id,
            daily_report_time=time(hour, minute),
            timezone=schedule_update.timezone
        )
        
        # 2. 重新调度定时任务
        await self.reschedule_daily_report(user_id, schedule_update.time, schedule_update.timezone)
        
        return {
            "time": schedule_update.time,
            "timezone": schedule_update.timezone,
            "next_run": self.get_next_run_time(user_id)
        }
    
    async def reschedule_daily_report(self, user_id: str, time_str: str, timezone: str):
        """安全地重新调度任务（取消旧任务+创建新任务）"""
        job_id = f"daily_report_{user_id}"
        
        # 1. 取消旧任务（如果存在）
        try:
            self.scheduler.remove_job(job_id)
        except JobLookupError:
            pass  # 任务不存在，继续
        
        # 2. 创建新任务
        hour, minute = map(int, time_str.split(':'))
        
        # 使用APScheduler的时区支持
        self.scheduler.add_job(
            self.generate_daily_report,
            'cron',
            hour=hour,
            minute=minute,
            timezone=pytz.timezone(timezone),  # 支持时区
            id=job_id,
            args=[user_id],
            replace_existing=True  # 确保替换
        )
```

### 错误处理和UI反馈

#### 前端错误处理
```typescript
// 错误处理分级
const handleError = (error: any) => {
  if (error.response) {
    switch (error.response.status) {
      case 400:
      case 422:
        // 显示后端验证错误
        showErrorMessage(error.response.data.detail);
        break;
      case 500:
        showErrorMessage('服务器错误，请稍后重试');
        break;
      default:
        showErrorMessage('操作失败，请重试');
    }
  } else if (error.request) {
    showErrorMessage('网络连接失败，请检查网络');
  } else {
    showErrorMessage('发生未知错误');
  }
};
```

#### UI反馈策略
1. **加载状态**：显示加载动画，禁用所有交互
2. **保存中**：按钮显示"保存中..."并禁用
3. **保存成功**：
   - 显示成功提示（Toast）
   - 按钮灰显2秒，显示"已保存"
   - 2秒后恢复正常状态
4. **保存失败**：
   - 显示具体错误信息
   - 保持表单数据，允许重试
5. **时区提醒**：
   - 页面显示当前时区
   - 底部小字提示："如果您的系统时区发生变化，请重新保存设置"

### 数据流
```
用户选择时间 → 点击保存 → API请求 → 更新数据库 → 更新定时任务 → 返回成功
```

### 时区和调度策略

1. **统一存储策略**
   - 数据库存储：保存用户本地时间 + 时区（如 09:00 + Asia/Shanghai）
   - 或使用cron表达式 + 时区：`0 9 * * *` + `Asia/Shanghai`
   - 调度器使用APScheduler的时区感知功能

2. **夏令时处理**
   - 使用APScheduler 4.x版本，内置时区和夏令时支持
   - 调度时指定pytz.timezone，自动处理DST转换

3. **时区变更处理**
   - 页面底部显示提示："如果您的系统时区发生变化，请重新保存设置"
   - 每次加载页面时检测当前时区，与保存的时区不一致时高亮提示

### TimePicker组件选型

推荐使用以下组件之一：
1. **react-time-picker** - 轻量级，支持24小时格式
2. **rc-time-picker** - Ant Design体系，功能完整
3. **HTML5原生** - `<input type="time">`，最简单但样式受限

要求：
- 支持24小时格式显示
- 直接返回HH:mm字符串
- 无需秒精度（日报生成不需要精确到秒）

## Tests

### 单元测试
- [ ] Settings组件渲染测试
- [ ] 时间选择器交互测试（24小时格式，HH:mm输出）
- [ ] API调用模拟测试
- [ ] 时间格式验证测试（正则表达式）
- [ ] 后端：cron_expr_from_time(time, tz) 生成函数测试
- [ ] 后端：reschedule_job 取消+新建逻辑测试

### 功能测试
- [ ] 页面正确加载当前设置的时间
- [ ] 页面显示当前时区（如"Asia/Shanghai (本地)"）
- [ ] 时间选择器正常工作（24小时格式）
- [ ] 保存按钮触发API调用
- [ ] 成功保存后显示提示并灰显按钮2秒
- [ ] 错误处理测试：
  - [ ] 400/422错误显示后端验证详情
  - [ ] 500错误显示"服务器错误"提示
  - [ ] 网络错误显示"网络连接失败"

### 集成测试
- [ ] 完整的设置加载流程
- [ ] 完整的设置保存流程
- [ ] 设置保存到数据库（UTC时间或cron+时区）
- [ ] 定时任务重新调度验证（旧任务取消）
- [ ] 跨时区测试：
  - [ ] Mock时区为Asia/Tokyo验证
  - [ ] Mock时区为America/New_York验证
  - [ ] 验证夏令时处理正确

### E2E测试
- [ ] 用户打开Settings页面
- [ ] 修改时间并保存
- [ ] 验证新时间生效
- [ ] 触发时间前后±1分钟拉取日志，确认只有一次生成
- [ ] 修改系统时区后重新保存，验证调度正确

### 用户体验测试
- [ ] 界面简洁清晰
- [ ] 操作反馈及时（成功/失败/加载状态）
- [ ] 无需额外说明即可理解功能
- [ ] 时区显示清晰，避免用户误解