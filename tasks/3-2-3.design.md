# Design 3-2-3 - 工具包装一致性优化

## Requirements

### 问题描述
- 文件开头定义了 `_safe_tool` 但未实际使用
- 工具错误处理不一致，可能导致流中断
- 需要统一的错误返回格式

### 目标
- 为所有工具应用统一的错误处理包装
- 确保工具异常不会中断流式响应
- 提供一致的错误信息格式

## Solution

### 1. 实现统一的工具包装器

```python
def _wrap_tool_with_error_handling(self, tool: Tool) -> Tool:
    """包装工具，添加统一的错误处理"""
    original_func = tool.func
    original_afunc = getattr(tool, 'afunc', None)
    
    def sync_wrapper(*args, **kwargs):
        try:
            return original_func(*args, **kwargs)
        except Exception as e:
            logger.error(f"Tool {tool.name} failed", 
                       tool_name=tool.name,
                       error=str(e),
                       user_id=self.user_id)
            return {
                "error": str(e),
                "tool": tool.name,
                "success": False,
                "message": f"工具执行失败: {str(e)}"
            }
    
    async def async_wrapper(*args, **kwargs):
        try:
            if original_afunc:
                return await original_afunc(*args, **kwargs)
            else:
                # 在异步上下文中运行同步函数
                import asyncio
                loop = asyncio.get_event_loop()
                return await loop.run_in_executor(None, original_func, *args, **kwargs)
        except Exception as e:
            logger.error(f"Tool {tool.name} failed (async)", 
                       tool_name=tool.name,
                       error=str(e),
                       user_id=self.user_id)
            return {
                "error": str(e),
                "tool": tool.name,
                "success": False,
                "message": f"工具执行失败: {str(e)}"
            }
    
    # 创建新的工具实例，保留原有属性
    return Tool(
        name=tool.name,
        description=tool.description,
        func=sync_wrapper,
        afunc=async_wrapper,
        return_direct=tool.return_direct,
        args_schema=tool.args_schema
    )
```

### 2. 修改 _create_tools 方法

```python
def _create_tools(self) -> List[Tool]:
    """创建对话处理工具集，应用统一的错误处理"""
    user_context = {
        "user_id": self.user_id,
        "db_session": self.db,
        "user": self.user
    }
    
    # 获取原始工具列表
    raw_tools = create_conversation_tools(self.user_id, self.db, user_context)
    
    # 为每个工具应用错误处理包装
    wrapped_tools = []
    for tool in raw_tools:
        wrapped_tool = self._wrap_tool_with_error_handling(tool)
        wrapped_tools.append(wrapped_tool)
        logger.debug(f"Wrapped tool: {tool.name}", user_id=self.user_id)
    
    return wrapped_tools
```

### 3. 改进流式响应中的错误处理

```python
# 在 stream_response 方法中添加工具错误的特殊处理
if "tool" in chunk:
    tool_data = chunk["tool"]
    
    # 检查是否是错误响应
    if isinstance(tool_data.get("output"), dict) and "error" in tool_data["output"]:
        yield {
            "type": "tool_error",
            "tool_name": tool_data.get("name"),
            "error": tool_data["output"]["error"],
            "message": tool_data["output"].get("message", "工具执行失败"),
            "timestamp": datetime.now(timezone.utc).isoformat(),
            "id": str(uuid.uuid4())
        }
    else:
        # 正常的工具响应处理...
```

### 4. 添加工具健康检查（可选）

```python
async def check_tools_health(self) -> Dict[str, bool]:
    """检查所有工具的健康状态"""
    health_status = {}
    
    for tool in self.tools:
        try:
            # 尝试用最小参数调用工具
            if hasattr(tool, 'afunc'):
                await tool.afunc(test=True)
            else:
                tool.func(test=True)
            health_status[tool.name] = True
        except Exception:
            health_status[tool.name] = False
    
    return health_status
```

### 5. 错误恢复机制

```python
class ToolExecutionError(Exception):
    """工具执行错误"""
    def __init__(self, tool_name: str, original_error: Exception):
        self.tool_name = tool_name
        self.original_error = original_error
        super().__init__(f"Tool {tool_name} failed: {str(original_error)}")

# 在包装器中使用自定义异常
def _handle_tool_error(self, tool_name: str, error: Exception) -> Dict:
    """统一的工具错误处理"""
    error_id = str(uuid.uuid4())
    
    # 记录详细错误信息
    logger.error("Tool execution failed",
                tool_name=tool_name,
                error_type=type(error).__name__,
                error_message=str(error),
                error_id=error_id,
                user_id=self.user_id)
    
    # 返回结构化错误响应
    return {
        "error": str(error),
        "error_type": type(error).__name__,
        "error_id": error_id,
        "tool": tool_name,
        "success": False,
        "message": self._get_user_friendly_error_message(error),
        "timestamp": datetime.now(timezone.utc).isoformat()
    }

def _get_user_friendly_error_message(self, error: Exception) -> str:
    """将技术错误转换为用户友好的消息"""
    error_messages = {
        "ConnectionError": "连接服务失败，请稍后重试",
        "TimeoutError": "操作超时，请稍后重试",
        "ValueError": "输入参数有误，请检查后重试",
        "PermissionError": "权限不足，无法执行此操作"
    }
    
    error_type = type(error).__name__
    return error_messages.get(error_type, f"操作失败: {str(error)}")
```

## Tests

### 单元测试

1. **test_tool_error_handling**
   ```python
   async def test_tool_error_handling():
       """测试工具错误处理"""
       handler = ConversationHandler("test_user", db_session)
       
       # 创建一个会抛出异常的模拟工具
       def failing_tool():
           raise ValueError("Test error")
       
       mock_tool = Tool(name="test_tool", func=failing_tool)
       wrapped_tool = handler._wrap_tool_with_error_handling(mock_tool)
       
       # 执行工具并验证错误响应格式
       result = wrapped_tool.func()
       assert result["success"] is False
       assert "error" in result
       assert result["tool"] == "test_tool"
   ```

2. **test_async_tool_wrapper**
   ```python
   async def test_async_tool_wrapper():
       """测试异步工具包装"""
       handler = ConversationHandler("test_user", db_session)
       
       async def async_tool():
           return {"result": "success"}
       
       tool = Tool(name="async_test", func=lambda: None, afunc=async_tool)
       wrapped_tool = handler._wrap_tool_with_error_handling(tool)
       
       result = await wrapped_tool.afunc()
       assert result["result"] == "success"
   ```

3. **test_error_message_formatting**
   ```python
   def test_error_message_formatting():
       """测试错误消息格式化"""
       handler = ConversationHandler("test_user", db_session)
       
       # 测试不同类型的错误
       errors = [
           ConnectionError("Network error"),
           TimeoutError("Timeout"),
           ValueError("Invalid input")
       ]
       
       for error in errors:
           message = handler._get_user_friendly_error_message(error)
           assert isinstance(message, str)
           assert len(message) > 0
   ```

### 集成测试

1. **test_stream_with_tool_errors**
   ```python
   async def test_stream_with_tool_errors():
       """测试包含工具错误的流式响应"""
       handler = ConversationHandler("test_user", db_session)
       
       # 发送会触发工具错误的消息
       events = []
       async for event in handler.stream_response("触发错误的命令", "session_1"):
           events.append(event)
       
       # 验证错误事件格式
       error_events = [e for e in events if e["type"] == "tool_error"]
       assert len(error_events) > 0
       assert "error" in error_events[0]
   ```

2. **test_tools_health_check**
   ```python
   async def test_tools_health_check():
       """测试工具健康检查"""
       handler = ConversationHandler("test_user", db_session)
       health = await handler.check_tools_health()
       
       assert isinstance(health, dict)
       assert all(isinstance(v, bool) for v in health.values())
   ```

### 验收标准

- [ ] 所有工具都应用了错误处理包装
- [ ] 工具异常不会导致流式响应中断
- [ ] 错误响应格式统一且包含必要信息
- [ ] 用户看到的错误消息友好易懂
- [ ] 错误日志记录完整便于调试