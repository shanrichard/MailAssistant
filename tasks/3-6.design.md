# Design 3-6: 修复 WebSocket 连接错误和改进错误处理

## Requirements

### 问题描述
1. **弱引用缓存竞态条件**：`ConversationHandler._checkpointer_cache` 使用 `weakref.WeakValueDictionary()` 导致在垃圾回收时值可能被意外回收，引发 `KeyError`
2. **错误信息不友好**：当发生 `KeyError` 时，前端只收到用户ID字符串（如 `'user_60f2ccbd-d754-4fa0-aa4d-35a7d6551d38'`），用户无法理解
3. **缺少错误恢复机制**：遇到暂时性错误时没有自动重试机制

### 功能需求
1. 修复 checkpointer 缓存的竞态条件，确保稳定性
2. 提供清晰、用户友好的错误消息
3. 实现智能的错误恢复和重试机制
4. 保持向后兼容性，不影响现有功能

### 非功能需求
1. 错误处理应该快速响应，不影响用户体验
2. 日志记录应该详细但不泄露敏感信息
3. 重试机制应该有合理的限制，避免无限循环

## Solution

### 整体架构设计

本方案采用分层架构，包含以下核心组件：

1. **缓存层**：使用TTL缓存替代弱引用字典，结合LRU淘汰策略
2. **错误处理层**：分类错误系统，提供用户友好的错误消息
3. **重试机制层**：智能重试策略，支持指数退避
4. **前端恢复层**：前端错误恢复管理器，支持断线重连

### 技术实现细节

#### 1. TTL缓存机制（替代弱引用字典）

```python
from datetime import datetime, timedelta
import threading
from typing import Dict, Any, Callable, Optional

class CheckpointerCache:
    """
    线程安全的TTL缓存，支持LRU淘汰策略
    解决弱引用字典的竞态条件问题
    """
    def __init__(self, max_size: int = 1000, ttl_hours: int = 24):
        self._cache: Dict[str, tuple[Any, datetime]] = {}
        self._access_count: Dict[str, int] = {}
        self._lock = threading.RLock()
        self._max_size = max_size
        self._ttl = timedelta(hours=ttl_hours)
        
    def get_or_create(self, key: str, factory: Callable[[], Any]) -> Any:
        """获取或创建缓存项，保证线程安全"""
        with self._lock:
            # 清理过期项
            self._cleanup_expired()
            
            # 检查缓存
            if key in self._cache:
                value, expire_time = self._cache[key]
                if datetime.now() < expire_time:
                    self._access_count[key] = self._access_count.get(key, 0) + 1
                    return value
                else:
                    del self._cache[key]
                    del self._access_count[key]
            
            # 创建新值
            value = factory()
            expire_time = datetime.now() + self._ttl
            
            # LRU淘汰
            if len(self._cache) >= self._max_size:
                self._evict_lru()
            
            self._cache[key] = (value, expire_time)
            self._access_count[key] = 1
            return value
    
    def _cleanup_expired(self):
        """清理过期的缓存项"""
        now = datetime.now()
        expired_keys = [k for k, (_, expire) in self._cache.items() if expire <= now]
        for key in expired_keys:
            del self._cache[key]
            self._access_count.pop(key, None)
    
    def _evict_lru(self):
        """基于访问频率的LRU淘汰"""
        if not self._cache:
            return
        # 找出访问次数最少的项
        lru_key = min(self._access_count.items(), key=lambda x: x[1])[0]
        del self._cache[lru_key]
        del self._access_count[lru_key]
```

#### 2. 错误分类和处理系统

```python
from enum import Enum
from typing import Optional, Dict, Any

class ErrorCategory(Enum):
    """错误分类，用于确定处理策略"""
    TEMPORARY = "temporary"          # 暂时性错误，可重试
    AUTHENTICATION = "auth"          # 认证错误
    VALIDATION = "validation"        # 输入验证错误
    SYSTEM = "system"               # 系统错误
    UNKNOWN = "unknown"             # 未知错误

class AppError(Exception):
    """应用级错误基类，提供用户友好的错误信息"""
    def __init__(self, 
                 message: str,
                 category: ErrorCategory,
                 user_message: Optional[str] = None,
                 details: Optional[Dict[str, Any]] = None,
                 retryable: bool = False):
        super().__init__(message)
        self.category = category
        self.user_message = user_message or self._get_default_user_message()
        self.details = details or {}
        self.retryable = retryable
        
    def _get_default_user_message(self) -> str:
        """根据错误类型返回默认的用户友好消息"""
        messages = {
            ErrorCategory.TEMPORARY: "服务暂时不可用，请稍后重试",
            ErrorCategory.AUTHENTICATION: "认证失败，请重新登录",
            ErrorCategory.VALIDATION: "输入有误，请检查后重试",
            ErrorCategory.SYSTEM: "系统错误，我们正在修复",
            ErrorCategory.UNKNOWN: "出现了意外错误，请稍后重试"
        }
        return messages.get(self.category, "操作失败")

def translate_error(exception: Exception) -> AppError:
    """将各种异常转换为用户友好的错误"""
    if isinstance(exception, KeyError):
        return AppError(
            message=str(exception),
            category=ErrorCategory.TEMPORARY,
            user_message="系统正在初始化，请稍后重试",
            retryable=True
        )
    elif isinstance(exception, ConnectionError):
        return AppError(
            message=str(exception),
            category=ErrorCategory.TEMPORARY,
            user_message="网络连接失败，请检查网络",
            retryable=True
        )
    # ... 其他错误类型
    else:
        return AppError(
            message=str(exception),
            category=ErrorCategory.UNKNOWN,
            retryable=True
        )
```

#### 3. 智能重试机制

```python
import asyncio
from functools import wraps
from typing import Tuple, Type, Callable, Any

class RetryPolicy:
    """重试策略配置"""
    def __init__(self, 
                 max_attempts: int = 3,
                 base_delay: float = 1.0,
                 max_delay: float = 60.0,
                 exponential_base: float = 2.0,
                 retryable_exceptions: Tuple[Type[Exception], ...] = ()):
        self.max_attempts = max_attempts
        self.base_delay = base_delay
        self.max_delay = max_delay
        self.exponential_base = exponential_base
        self.retryable_exceptions = retryable_exceptions or (
            KeyError, ConnectionError, TimeoutError
        )

def with_retry(policy: RetryPolicy):
    """装饰器：为异步函数添加重试功能"""
    def decorator(func: Callable) -> Callable:
        @wraps(func)
        async def wrapper(*args, **kwargs) -> Any:
            last_exception = None
            
            for attempt in range(policy.max_attempts):
                try:
                    return await func(*args, **kwargs)
                except policy.retryable_exceptions as e:
                    last_exception = e
                    
                    if attempt < policy.max_attempts - 1:
                        # 计算延迟时间（指数退避）
                        delay = min(
                            policy.base_delay * (policy.exponential_base ** attempt),
                            policy.max_delay
                        )
                        logger.info(
                            f"Retry attempt {attempt + 1}/{policy.max_attempts} "
                            f"after {delay}s delay for {func.__name__}"
                        )
                        await asyncio.sleep(delay)
                    else:
                        logger.error(f"All retry attempts failed for {func.__name__}: {e}")
            
            # 所有重试都失败，抛出用户友好的错误
            raise translate_error(last_exception)
            
        return wrapper
    return decorator
```

#### 4. 前端错误恢复管理

```typescript
// 前端错误恢复系统
interface RetryConfig {
  maxAttempts: number;
  baseDelay: number;
  maxDelay: number;
}

interface ErrorEvent {
  type: 'error';
  error: string;
  error_code: string;
  retryable: boolean;
  timestamp: string;
}

class ErrorRecoveryManager {
  private retryQueue: Map<string, RetryTask> = new Map();
  private retryConfig: RetryConfig = {
    maxAttempts: 3,
    baseDelay: 1000,
    maxDelay: 5000
  };
  
  async executeWithRetry<T>(
    taskId: string,
    operation: () => Promise<T>,
    onRetry?: (attempt: number) => void,
    onError?: (error: any) => void
  ): Promise<T> {
    let lastError: any = null;
    
    for (let attempt = 0; attempt < this.retryConfig.maxAttempts; attempt++) {
      try {
        return await operation();
      } catch (error) {
        lastError = error;
        
        if (this.isRetryable(error) && attempt < this.retryConfig.maxAttempts - 1) {
          const delay = this.calculateDelay(attempt);
          onRetry?.(attempt + 1);
          await this.delay(delay);
        } else {
          onError?.(error);
          break;
        }
      }
    }
    
    throw lastError;
  }
  
  private isRetryable(error: any): boolean {
    // 检查错误是否可重试
    if (error?.retryable === true) return true;
    if (error?.error_code === 'temporary') return true;
    if (error?.code === 'ECONNABORTED') return true;
    return false;
  }
  
  private calculateDelay(attempt: number): number {
    const delay = Math.min(
      this.retryConfig.baseDelay * Math.pow(2, attempt),
      this.retryConfig.maxDelay
    );
    // 添加随机抖动，避免同时重试
    return delay + Math.random() * 1000;
  }
  
  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
```

### 集成方案

1. **修改 ConversationHandler**：
   - 替换 `_checkpointer_cache` 为新的 `CheckpointerCache`
   - 在 `_get_checkpointer` 方法中使用新的缓存机制
   - 添加重试装饰器到关键方法

2. **修改 socketio_app.py**：
   - 更新错误处理逻辑，使用 `translate_error` 函数
   - 确保所有错误都转换为用户友好的格式
   - 添加错误日志记录

3. **修改前端 chatStore**：
   - 集成 `ErrorRecoveryManager`
   - 更新 `sendMessage` 方法支持自动重试
   - 添加重试状态的UI反馈

## Tests

### 单元测试
1. **缓存稳定性测试**：模拟高并发访问，验证无竞态条件
2. **错误转换测试**：验证各种异常都能正确转换为友好消息
3. **重试逻辑测试**：验证重试次数、延迟时间和最终失败处理

### 集成测试
1. **端到端错误处理**：从前端触发错误，验证整个错误处理流程
2. **断线重连测试**：模拟网络中断，验证自动恢复机制
3. **并发用户测试**：多用户同时使用，验证缓存和错误处理的稳定性

### 性能测试
1. **内存使用测试**：长时间运行，监控缓存内存使用
2. **响应时间测试**：验证错误处理不影响正常响应时间
3. **压力测试**：大量并发请求下的系统稳定性