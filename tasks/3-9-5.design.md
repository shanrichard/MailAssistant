# Design 3-9-5: 实现幂等同步启动接口

## Requirements
- 重新设计同步启动逻辑，避免重复任务和状态冲突
- 如果存在有效的进行中任务（<30分钟），则复用现有task_id
- 使用行锁保证并发安全
- 提升用户体验，防止狂点按钮创建重复任务

## Solution
**基于专家建议的幂等接口设计**：

### 1. 幂等启动函数
```python
def start_sync_idempotent(user_id: str, force_full: bool) -> str:
    """
    幂等的同步启动接口
    - 如果存在有效的进行中任务（<30分钟），则复用现有task_id
    - 否则，清理旧状态并创建新任务
    - 使用行锁保证并发安全
    """
    from datetime import datetime, timedelta
    import uuid
    
    with db.begin():
        # 使用行锁获取用户同步状态
        sync_status = db.query(UserSyncStatus).filter(
            UserSyncStatus.user_id == user_id
        ).with_for_update().first()

        now = datetime.utcnow()
        
        # 检查是否存在有效的进行中任务
        if (sync_status and 
            sync_status.is_syncing and 
            sync_status.started_at and
            (now - sync_status.started_at) < timedelta(minutes=30)):
            
            logger.info(f"复用现有同步任务: {sync_status.task_id}", user_id=user_id)
            return sync_status.task_id  # 复用老任务，避免重复
        
        # 创建新任务
        new_task_id = f"sync_{user_id}_{uuid.uuid4().hex[:8]}_{int(now.timestamp())}"
        
        if sync_status:
            # 更新现有记录
            sync_status.task_id = new_task_id
            sync_status.is_syncing = True
            sync_status.sync_type = 'full' if force_full else 'incremental'
            sync_status.started_at = now
            sync_status.updated_at = now
            sync_status.progress_percentage = 0
            sync_status.current_stats = {}
            sync_status.error_message = None
        else:
            # 创建新记录
            sync_status = UserSyncStatus(
                user_id=user_id,
                task_id=new_task_id,
                is_syncing=True,
                sync_type='full' if force_full else 'incremental',
                started_at=now,
                updated_at=now,
                progress_percentage=0,
                current_stats={}
            )
            db.add(sync_status)
        
        # 事务提交，确保数据库状态先更新
        
    # 事务提交后再异步启动真正的同步逻辑
    logger.info(f"启动新同步任务: {new_task_id}", user_id=user_id, force_full=force_full)
    return new_task_id
```

### 2. API接口重构
```python
@router.post("/sync/smart", response_model=SyncResponse)
async def smart_sync_emails(
    force_full: bool = Query(default=False),
    background_tasks: BackgroundTasks = None,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
) -> SyncResponse:
    """改进的智能同步API"""
    try:
        # 使用幂等启动接口
        task_id = start_sync_idempotent(current_user.id, force_full)
        
        # 启动后台任务
        if background_tasks:
            background_tasks.add_task(
                execute_background_sync_v2, current_user.id, force_full, task_id
            )
        
        return SyncResponse(
            success=True,
            stats={},
            message="同步任务已启动",
            task_id=task_id,
            in_progress=True
        )
        
    except Exception as e:
        logger.error(f"启动同步失败: {e}", user_id=current_user.id)
        raise HTTPException(status_code=400, detail=f"启动同步失败: {str(e)}")
```

## Tests
- 连续多次调用同步接口，验证任务复用逻辑正确
- 单用户多次快速点击，确认不会创建重复任务
- 多用户同时启动同步，验证并发安全性
- 测试任务超时后的自动清理和新任务创建

**优势**：
- 防止重复任务：用户狂点按钮不会创建多个任务
- 自动任务复用：有效任务直接复用，提升用户体验
- 并发安全：行锁保证只有一个分支能写入 `is_syncing=TRUE`
- 状态清理：自动清理过期任务状态