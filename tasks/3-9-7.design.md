# Design 3-9-7: 实现自动清理和健康检查系统

## Requirements
- 基于心跳的更精确清理策略
- 每2分钟自动检测和清理僵死任务
- 提供全面的健康检查接口
- 实现系统自愈能力

## Solution

### 1. 基于心跳的僵死任务清理
```python
async def cleanup_zombie_tasks_v2():
    """基于心跳的僵死任务清理"""
    HEARTBEAT_TIMEOUT = 60  # 心跳超时时间（2个心跳周期）
    
    db = SessionLocal()
    try:
        cutoff_time = datetime.utcnow() - timedelta(seconds=HEARTBEAT_TIMEOUT)
        
        # 查找僵死任务：正在同步但心跳超时
        zombie_tasks = db.query(UserSyncStatus).filter(
            UserSyncStatus.is_syncing == True,
            UserSyncStatus.updated_at < cutoff_time
        ).all()
        
        for task in zombie_tasks:
            logger.warning(
                f"检测到僵死任务，自动清理: {task.task_id}",
                user_id=task.user_id,
                last_update=task.updated_at,
                minutes_silent=(datetime.utcnow() - task.updated_at).total_seconds() / 60
            )
            
            # 原子性清理
            release_sync_status_atomic(
                task.user_id,
                task.task_id,
                f"任务心跳超时，自动清理于 {datetime.utcnow()}"
            )
            
        if zombie_tasks:
            logger.info(f"自动清理了 {len(zombie_tasks)} 个僵死任务")
            
        return len(zombie_tasks)
        
    except Exception as e:
        logger.error(f"僵死任务清理失败: {e}")
        return 0
    finally:
        db.close()

# 定时任务
@scheduler.scheduled_job('interval', minutes=2, id='zombie_task_cleaner_v2')
async def scheduled_zombie_cleanup():
    """每2分钟清理一次僵死任务"""
    cleaned_count = await cleanup_zombie_tasks_v2()
    if cleaned_count > 0:
        logger.info(f"定时清理完成，清理了 {cleaned_count} 个僵死任务")
```

### 2. 增强版健康检查接口
```python
@router.get("/sync/health")
async def sync_health_check_v2(db: Session = Depends(get_db)):
    """增强版同步系统健康检查"""
    try:
        now = datetime.utcnow()
        
        # 统计各种状态的任务
        total_users = db.query(UserSyncStatus).count()
        active_syncs = db.query(UserSyncStatus).filter(
            UserSyncStatus.is_syncing == True
        ).count()
        
        # 检测僵死任务（心跳超时）
        heartbeat_timeout = now - timedelta(seconds=60)
        zombie_tasks = db.query(UserSyncStatus).filter(
            UserSyncStatus.is_syncing == True,
            UserSyncStatus.updated_at < heartbeat_timeout
        ).all()
        
        # 检测数据一致性问题
        inconsistent_tasks = db.query(UserSyncStatus).filter(
            ~(
                (UserSyncStatus.is_syncing == True) & 
                (UserSyncStatus.progress_percentage.between(0, 99))
                | 
                (UserSyncStatus.is_syncing == False) & 
                (UserSyncStatus.progress_percentage.in_([0, 100]))
            )
        ).count()
        
        # 统计最近完成的同步
        recent_cutoff = now - timedelta(hours=1)
        recent_syncs = db.query(UserSyncStatus).filter(
            UserSyncStatus.updated_at > recent_cutoff,
            UserSyncStatus.is_syncing == False,
            UserSyncStatus.progress_percentage == 100
        ).count()
        
        health_status = {
            "healthy": len(zombie_tasks) == 0 and inconsistent_tasks == 0,
            "timestamp": now.isoformat(),
            "statistics": {
                "total_users": total_users,
                "active_syncs": active_syncs,
                "zombie_tasks": len(zombie_tasks),
                "inconsistent_tasks": inconsistent_tasks,
                "recent_completed_syncs": recent_syncs
            },
            "zombie_task_details": [
                {
                    "task_id": task.task_id,
                    "user_id": str(task.user_id),
                    "started_at": task.started_at.isoformat() if task.started_at else None,
                    "last_update": task.updated_at.isoformat(),
                    "silent_minutes": int((now - task.updated_at).total_seconds() / 60)
                }
                for task in zombie_tasks[:5]  # 只显示前5个
            ]
        }
        
        if not health_status["healthy"]:
            logger.warning("同步系统健康检查发现问题", health_data=health_status)
            
        return health_status
        
    except Exception as e:
        error_response = {
            "healthy": False,
            "timestamp": datetime.utcnow().isoformat(),
            "error": str(e)
        }
        logger.error("健康检查执行失败", error_data=error_response)
        return error_response
```

### 3. 数据一致性检查工具
```python
async def verify_sync_status_consistency(db: Session):
    """验证同步状态数据一致性"""
    inconsistent_tasks = db.query(UserSyncStatus).filter(
        and_(
            UserSyncStatus.is_syncing == True,
            UserSyncStatus.progress_percentage == 0,
            UserSyncStatus.current_stats.is_(None)
        )
    ).all()
    
    return inconsistent_tasks
```

## Tests
- 创建模拟僵死任务，验证自动清理机制
- 测试健康检查接口的准确性和完整性
- 验证定时清理任务的正常运行
- 确认清理后系统可正常工作
- 测试各种异常情况的处理

**功能特点**：
- **精确检测**：基于心跳超时而非简单时间判断
- **自动恢复**：系统具有自愈能力，无需人工干预
- **全面监控**：提供详细的系统状态信息
- **问题预警**：主动发现并记录潜在问题