# Design 3-12-8

## Requirements

### 修复幂等启动逻辑缺陷

#### 问题分析
当前的幂等启动逻辑存在严重缺陷：
1. `start_sync_idempotent` 创建新任务时立即设置 `is_syncing=True`
2. `get_active_task_info` 检测到这个任务，认为是"活跃任务"
3. `smart_sync_emails` API 直接返回，不启动后台执行
4. 结果：任务被创建但永远不执行，形成"幽灵任务"

#### 需求目标
1. 保持幂等性：防止重复创建任务
2. 确保执行：新创建的任务必须启动后台执行
3. 正确复用：只有真正在执行的任务才应该被复用

## Solution

### 采纳专家建议：引入状态字段彻底解决问题

基于专家评审意见，采用状态拆分方案，彻底解决幂等逻辑缺陷：

#### 1. 数据库迁移
```python
# backend/alembic/versions/xxx_add_sync_status_field.py
def upgrade():
    # 添加 status 字段
    op.add_column('user_sync_status', 
        sa.Column('status', sa.String(20), nullable=False, server_default='CREATED')
    )
    
    # 更新现有数据
    connection = op.get_bind()
    connection.execute("""
        UPDATE user_sync_status 
        SET status = CASE 
            WHEN is_syncing = true THEN 'RUNNING'
            WHEN progress_percentage = 100 THEN 'SUCCEEDED'
            ELSE 'FAILED'
        END
    """)
    
    # 创建索引提高查询性能
    op.create_index('idx_user_sync_status_status', 'user_sync_status', ['status'])
```

#### 2. 更新模型
```python
# backend/app/models/user_sync_status.py
from enum import Enum

class SyncStatus(str, Enum):
    CREATED = "CREATED"
    RUNNING = "RUNNING"
    SUCCEEDED = "SUCCEEDED"
    FAILED = "FAILED"
    ABORTED = "ABORTED"

class UserSyncStatus(Base):
    # ... 现有字段 ...
    status = Column(String(20), nullable=False, default=SyncStatus.CREATED)
```

#### 3. 修改幂等启动逻辑
```python
# backend/app/services/sync_service.py
def start_sync_idempotent(db: Session, user_id: str, force_full: bool = False) -> str:
    """创建或复用同步任务，使用状态字段判断"""
    sync_status = db.query(UserSyncStatus).filter(
        UserSyncStatus.user_id == user_id
    ).first()
    
    # 只有 RUNNING 状态才认为是活跃任务
    if sync_status and sync_status.status == SyncStatus.RUNNING:
        logger.info(f"复用现有RUNNING任务: {sync_status.task_id}")
        return sync_status.task_id
    
    # 创建新任务，初始状态为 CREATED
    task_id = f"sync_{uuid.uuid4()}"
    if sync_status:
        sync_status.task_id = task_id
        sync_status.status = SyncStatus.CREATED  # 关键：不是 RUNNING
        sync_status.is_syncing = False           # 保持兼容
        sync_status.progress_percentage = 0
        sync_status.started_at = None
        sync_status.error_message = None
    else:
        sync_status = UserSyncStatus(
            user_id=user_id,
            task_id=task_id,
            status=SyncStatus.CREATED,
            is_syncing=False,
            progress_percentage=0
        )
        db.add(sync_status)
    
    db.commit()
    logger.info(f"创建新任务: {task_id}，状态: CREATED")
    return task_id
```

#### 4. 后台任务启动时更新状态
```python
# backend/app/services/heartbeat_sync_service.py
async def execute_background_sync_with_heartbeat(user_id: str, force_full: bool, task_id: str):
    """执行后台同步，立即更新状态为RUNNING"""
    db = SessionLocal()
    try:
        # 第一步：立即更新状态为 RUNNING
        sync_status = db.query(UserSyncStatus).filter(
            UserSyncStatus.user_id == user_id,
            UserSyncStatus.task_id == task_id
        ).first()
        
        if not sync_status:
            logger.error(f"任务不存在: {task_id}")
            return
        
        # 原子更新为RUNNING状态
        sync_status.status = SyncStatus.RUNNING
        sync_status.is_syncing = True
        sync_status.started_at = datetime.now(timezone.utc)
        sync_status.updated_at = datetime.now(timezone.utc)
        db.commit()
        
        logger.info(f"任务状态更新为RUNNING", extra={"task_id": task_id})
        
        # 继续执行同步逻辑...
        await sync_emails_with_progress(user_id, force_full, task_id)
        
        # 成功完成
        sync_status.status = SyncStatus.SUCCEEDED
        sync_status.is_syncing = False
        sync_status.progress_percentage = 100
        db.commit()
        
    except Exception as e:
        # 失败处理
        logger.error(f"同步失败: {e}", extra={"task_id": task_id})
        if sync_status:
            sync_status.status = SyncStatus.FAILED
            sync_status.is_syncing = False
            sync_status.error_message = str(e)
            db.commit()
    finally:
        db.close()
```

#### 5. 更新API判断逻辑
```python
# backend/app/api/gmail.py
@router.post("/sync/smart")
async def smart_sync_emails(...):
    # 使用幂等启动接口
    task_id = start_sync_idempotent(db, current_user.id, force_full)
    
    # 检查任务状态
    sync_status = db.query(UserSyncStatus).filter(
        UserSyncStatus.user_id == current_user.id,
        UserSyncStatus.task_id == task_id
    ).first()
    
    # 如果是RUNNING状态，说明是复用的任务
    if sync_status and sync_status.status == SyncStatus.RUNNING:
        logger.info(f"复用现有RUNNING任务: {task_id}")
        return SyncResponse(
            success=True,
            message="复用进行中的同步任务",
            in_progress=True,
            task_id=task_id
        )
    
    # 否则是新任务，启动后台执行
    logger.info(f"启动新任务的后台执行: {task_id}")
    # ... asyncio.create_task 代码 ...
```

### 优势
1. **彻底解决竞态问题**：不再依赖时间判断
2. **状态清晰**：CREATED → RUNNING → SUCCEEDED/FAILED
3. **易于监控**：可以准确统计各种状态的任务
4. **向后兼容**：保留 is_syncing 字段

## Tests

### 测试场景
1. **首次同步**：确保任务创建并执行
2. **快速重复点击**：确保不创建重复任务，返回同一个task_id
3. **任务执行中再次点击**：确保复用现有任务
4. **任务完成后再次点击**：确保创建新任务

### 验证方法
```python
# 测试脚本
async def test_sync_logic():
    # 1. 第一次调用
    response1 = await client.post("/api/gmail/sync/smart")
    task_id1 = response1.json()["task_id"]
    
    # 2. 立即再次调用（1秒内）
    await asyncio.sleep(0.5)
    response2 = await client.post("/api/gmail/sync/smart")
    task_id2 = response2.json()["task_id"]
    
    # 应该是同一个任务
    assert task_id1 == task_id2
    
    # 3. 等待几秒，确认任务在执行
    await asyncio.sleep(5)
    
    # 检查进度是否更新
    progress_response = await client.get(f"/api/gmail/sync/progress/{task_id1}")
    assert progress_response.json()["progress_percentage"] > 0
```

## 实施步骤
1. 修改 `smart_sync_emails` 函数，添加时间判断逻辑
2. 添加详细日志，便于调试
3. 测试各种场景，确保逻辑正确
4. 监控生产环境，确保没有新的问题