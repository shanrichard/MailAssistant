# Design 3-4-2 - 创建日志查看 API

## Requirements

创建 API 端点，让 Claude 能够查看前端（存储在 localStorage）和后端的错误日志。

### 需求细节

1. **获取前端错误日志**
   - 通过特殊的 API 端点获取前端 localStorage 中的错误
   - 需要前端配合，在请求时附带 localStorage 数据

2. **获取后端错误日志**
   - 读取后端日志文件中的错误信息
   - 支持按时间、级别过滤

3. **统一的日志格式**
   - 前后端日志统一返回格式
   - 按时间倒序排列

## Solution

### 技术方案

#### 1. API 端点设计

```python
# backend/app/api/debug_logs.py
from fastapi import APIRouter, Query, Request
from typing import Optional, List, Dict
from datetime import datetime
import json
import os

router = APIRouter(prefix="/api/debug/logs", tags=["debug"])

@router.post("/all")
async def get_all_logs(request: Request):
    """
    获取前后端所有错误日志
    前端需要在请求体中传入 localStorage 的错误数据
    """
    # 只在开发环境启用
    if os.getenv("ENVIRONMENT") != "development":
        return {"error": "This endpoint is only available in development"}
    
    # 获取前端传来的错误
    body = await request.json()
    frontend_errors = body.get("frontend_errors", [])
    
    # 获取后端错误
    backend_errors = await get_backend_errors(limit=100)
    
    # 合并并排序
    all_errors = []
    
    # 转换前端错误格式
    for error in frontend_errors:
        all_errors.append({
            "source": "frontend",
            "timestamp": error.get("timestamp"),
            "type": error.get("type"),
            "message": error.get("message"),
            "stack": error.get("stack"),
            "url": error.get("url")
        })
    
    # 添加后端错误
    all_errors.extend(backend_errors)
    
    # 按时间倒序排序
    all_errors.sort(key=lambda x: x.get("timestamp", ""), reverse=True)
    
    return {
        "errors": all_errors[:200],  # 最多返回200条
        "frontend_count": len(frontend_errors),
        "backend_count": len(backend_errors),
        "total_count": len(all_errors)
    }

@router.get("/backend")
async def get_backend_logs(
    limit: int = Query(100, le=500),
    level: Optional[str] = Query(None, description="error/warning/info")
):
    """仅获取后端日志"""
    if os.getenv("ENVIRONMENT") != "development":
        return {"error": "This endpoint is only available in development"}
    
    errors = await get_backend_errors(limit=limit, level=level)
    return {
        "errors": errors,
        "count": len(errors)
    }

async def get_backend_errors(limit: int = 100, level: Optional[str] = None) -> List[Dict]:
    """从日志文件读取后端错误"""
    errors = []
    log_file_path = "logs/app.log"  # 根据实际日志路径调整
    
    if not os.path.exists(log_file_path):
        return []
    
    try:
        with open(log_file_path, 'r', encoding='utf-8') as f:
            # 读取最后的 N 行
            lines = f.readlines()[-limit * 2:]  # 读取多一些以便过滤
            
        for line in reversed(lines):
            try:
                # 假设日志是 JSON 格式
                log_entry = json.loads(line.strip())
                
                # 过滤级别
                if level and log_entry.get("level") != level:
                    continue
                
                # 只获取 error 和 warning
                if log_entry.get("level") in ["error", "warning"]:
                    errors.append({
                        "source": "backend",
                        "timestamp": log_entry.get("timestamp"),
                        "type": "backend_log",
                        "message": log_entry.get("message"),
                        "level": log_entry.get("level"),
                        "logger": log_entry.get("logger"),
                        "context": log_entry.get("context", {})
                    })
                
                if len(errors) >= limit:
                    break
                    
            except json.JSONDecodeError:
                # 如果不是 JSON 格式，尝试解析为文本
                if "ERROR" in line or "WARNING" in line:
                    errors.append({
                        "source": "backend",
                        "timestamp": datetime.now().isoformat(),
                        "type": "backend_log",
                        "message": line.strip(),
                        "level": "error" if "ERROR" in line else "warning"
                    })
    except Exception as e:
        return [{
            "source": "backend",
            "timestamp": datetime.now().isoformat(),
            "type": "error",
            "message": f"Failed to read log file: {str(e)}"
        }]
    
    return errors[:limit]
```

#### 2. 前端辅助函数

```typescript
// frontend/src/utils/debugHelper.ts
import { errorCollector } from './errorCollector';
import axios from 'axios';

export const sendLogsToBackend = async () => {
  // 只在开发环境执行
  if (process.env.NODE_ENV !== 'development') {
    return;
  }

  try {
    const frontendErrors = errorCollector.getAllErrors();
    
    const response = await axios.post('/api/debug/logs/all', {
      frontend_errors: frontendErrors
    });
    
    return response.data;
  } catch (error) {
    console.error('Failed to send logs to backend:', error);
    return null;
  }
};

// 可以在控制台手动调用的全局函数
if (process.env.NODE_ENV === 'development') {
  (window as any).debugLogs = {
    send: sendLogsToBackend,
    clear: () => errorCollector.clearErrors(),
    get: () => errorCollector.getAllErrors()
  };
}
```

### 使用方式

1. Claude 可以通过调用 API 获取日志：
   ```bash
   # 获取所有日志（需要前端配合）
   curl -X POST http://localhost:8000/api/debug/logs/all \
     -H "Content-Type: application/json" \
     -d '{"frontend_errors": []}'
   
   # 仅获取后端日志
   curl http://localhost:8000/api/debug/logs/backend?limit=50
   ```

2. 开发者可以在浏览器控制台手动发送日志：
   ```javascript
   // 发送日志到后端
   await window.debugLogs.send()
   
   // 查看本地错误
   window.debugLogs.get()
   
   // 清除错误
   window.debugLogs.clear()
   ```

## Tests

- [ ] API 只在开发环境可访问
- [ ] 前端错误正确传递到后端
- [ ] 后端日志正确读取和解析
- [ ] 错误按时间正确排序
- [ ] 返回数量限制生效