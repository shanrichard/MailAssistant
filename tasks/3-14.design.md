# Design 3-14: 优化邮件同步性能

## Requirements

### 背景问题
当前邮件同步存在严重的性能问题：
- **21秒同步时间过长**：即使没有新邮件，同步今天的邮件也需要21秒
- **N+1查询问题**：对每封邮件都单独调用Gmail API获取详情（50封邮件=51次API调用）
- **无效的重复处理**：每次都获取所有今天的邮件详情，即使大部分邮件已经同步过

### 性能需求
1. **同步时间显著缩短**：
   - 无新邮件情况下：从21秒缩短到2-3秒以内
   - 有少量新邮件（1-5封）：缩短到5秒以内
   - 有大量新邮件（20+封）：仍需优化到10秒以内

2. **API调用次数优化**：
   - 当前：1+N次调用（N为邮件数量）
   - 目标：1+ceil(变更邮件数/50)次调用

3. **增量同步能力**：
   - 只同步真正有变更的邮件（新邮件、标签变化、已读状态变化）
   - 支持基于historyId的增量检测
   - 避免重复处理已同步的邮件

### 功能需求
1. **Gmail History API集成**：
   - 使用historyId机制检测邮件变更
   - 存储和管理用户的lastHistoryId
   - 处理historyId过期的fallback机制

2. **批量API支持**：
   - 实现Gmail API批量请求功能
   - 一次性获取多个邮件的详细信息（最多50个）
   - 错误处理和重试机制

3. **智能同步策略**：
   - 优先使用增量同步（history API）
   - 批量获取变更邮件的详情
   - 保持现有的数据库更新逻辑

4. **性能监控**：
   - 记录各阶段的耗时统计
   - 监控API调用次数
   - 提供性能对比数据

### 兼容性需求
1. **保持现有API接口不变**：`/gmail/sync/today`等端点行为保持一致
2. **数据库结构兼容**：不破坏现有的Email模型和数据
3. **错误处理兼容**：保持现有的错误处理机制和日志格式

### 测试需求
1. **功能测试**：验证同步结果的正确性和完整性
2. **性能测试**：对比优化前后的同步时间和API调用次数
3. **边界测试**：测试无邮件、大量邮件、网络异常等场景

## Solution

### 架构设计

#### 1. 数据库扩展
在 `User` 模型中添加 `last_history_id` 字段，用于存储Gmail History API的检查点：
```python
class User(Base):
    # ... 现有字段
    last_history_id: Optional[str] = Column(String, nullable=True)
    last_history_sync: Optional[datetime] = Column(DateTime, nullable=True)
```

#### 2. Gmail服务扩展
在 `GmailService` 中新增三个核心方法：

**2.1 History API支持**
```python
def get_history_changes(self, user: User, start_history_id: str) -> Tuple[List[str], str]:
    """获取历史变更的邮件ID列表和新的historyId"""
    # 调用 users.history.list API
    # 返回变更的messageId列表和最新的historyId
```

**2.2 批量获取邮件详情**
```python
def get_messages_batch(self, user: User, message_ids: List[str]) -> List[Dict[str, Any]]:
    """批量获取邮件详情（最多50个）"""
    # 使用Gmail API的batch request功能
    # 分批处理，每批最多50个邮件
```

**2.3 获取当前historyId**
```python
def get_current_history_id(self, user: User) -> str:
    """获取用户当前的historyId"""
    # 调用 users.getProfile 获取historyId
```

#### 3. 同步服务重构
在 `EmailSyncService` 中重构核心同步方法：

**3.1 智能同步入口**
```python
def sync_emails_optimized(
    self, 
    db: Session, 
    user: User, 
    timerange: str = "today",
    force_full_sync: bool = False
) -> Dict[str, Any]:
    """优化的邮件同步方法"""
    # 性能监控开始
    # 判断是否使用增量同步
    # 执行相应的同步策略
    # 返回性能统计
```

**3.2 增量同步实现**
```python
def _incremental_sync_by_history(
    self, 
    db: Session, 
    user: User, 
    start_history_id: str
) -> Dict[str, Any]:
    """基于History API的增量同步"""
    # 1. 获取变更的邮件ID列表
    # 2. 批量获取邮件详情
    # 3. 更新数据库
    # 4. 更新用户的last_history_id
```

**3.3 批量处理工具**
```python
def _process_messages_batch(
    self, 
    db: Session, 
    user: User, 
    message_ids: List[str]
) -> Dict[str, int]:
    """批量处理邮件列表"""
    # 分批获取邮件详情（每批50个）
    # 批量数据库操作
    # 返回统计信息
```

#### 4. 性能监控组件
```python
class SyncPerformanceMonitor:
    """同步性能监控器"""
    def __init__(self):
        self.start_time = None
        self.api_calls = 0
        self.stages = {}
    
    def start_stage(self, stage_name: str):
        """开始一个阶段的计时"""
    
    def end_stage(self, stage_name: str):
        """结束一个阶段的计时"""
    
    def record_api_call(self):
        """记录API调用次数"""
    
    def get_report(self) -> Dict[str, Any]:
        """获取性能报告"""
```

### 实现策略（TDD开发流程）

#### 子任务3-14-1：数据库迁移
- **目标**：添加User模型的`last_history_id`和`last_history_sync`字段
- **交付物**：数据库迁移脚本
- **测试**：数据库schema验证

#### 子任务3-14-2：Gmail History API支持（TDD）
- **第1步**：编写History API相关的单元测试
  - `test_get_history_changes_success()`
  - `test_get_history_changes_expired_history_id()`
  - `test_get_current_history_id_success()`
- **第2步**：实现`get_history_changes()`和`get_current_history_id()`方法
- **第3步**：运行测试，确保通过
- **交付物**：Gmail服务中的History API方法 + 对应单元测试

#### 子任务3-14-3：Gmail API批量请求功能（TDD）
- **第1步**：编写批量请求的单元测试
  - `test_get_messages_batch_success()`
  - `test_get_messages_batch_partial_failure()`
  - `test_batch_processing_large_list()`
- **第2步**：实现`get_messages_batch()`方法
- **第3步**：运行测试，确保通过
- **交付物**：Gmail服务中的批量请求方法 + 对应单元测试

#### 子任务3-14-4：性能监控组件（TDD）
- **第1步**：编写性能监控器的单元测试
  - `test_stage_timing()`
  - `test_api_call_counting()`
  - `test_performance_report()`
- **第2步**：实现`SyncPerformanceMonitor`类
- **第3步**：运行测试，确保通过
- **交付物**：性能监控组件 + 对应单元测试

#### 子任务3-14-5：重构邮件同步服务核心逻辑（TDD）
- **第1步**：编写同步服务的单元测试
  - `test_sync_emails_optimized_no_changes()`
  - `test_sync_emails_optimized_with_changes()`
  - `test_incremental_sync_by_history_success()`
  - `test_process_messages_batch_large_batch()`
- **第2步**：实现优化后的同步方法
  - `sync_emails_optimized()`
  - `_incremental_sync_by_history()`
  - `_process_messages_batch()`
- **第3步**：运行测试，确保通过
- **交付物**：重构后的同步服务 + 对应单元测试

#### 子任务3-14-6：集成到API端点（TDD）
- **第1步**：编写API端点的单元测试
  - `test_sync_today_optimized_endpoint()`
  - `test_sync_performance_metrics_in_response()`
- **第2步**：修改`/gmail/sync/today`等端点，集成优化后的同步方法
- **第3步**：运行测试，确保通过
- **交付物**：更新后的API端点 + 对应单元测试

#### 子任务3-14-7：端到端集成测试
- **目标**：测试完整的同步流程
- **测试用例**：
  - `test_full_sync_flow_no_previous_history()`
  - `test_incremental_sync_flow_with_changes()`
  - `test_sync_today_api_endpoint()`
- **交付物**：集成测试套件

#### 子任务3-14-8：性能测试和效果验证
- **目标**：验证性能优化效果
- **测试用例**：
  - `test_sync_time_no_changes()` - 验证无变更同步时间 < 3秒
  - `test_sync_time_with_few_changes()` - 验证少量变更同步时间 < 5秒
  - `test_api_call_reduction()` - 验证API调用次数显著减少
- **交付物**：性能对比报告

### 错误处理策略（基于专家建议）

#### 1. historyId失效处理（关键风险）
```python
def fetch_changed_msg_ids(self, user: User, start_history_id: str) -> Tuple[List[str], str]:
    """获取变更的邮件ID，处理historyId过期"""
    try:
        return self.get_history_changes(user, start_history_id)
    except HttpError as e:
        if e.resp.status == 404:  # historyId过期（>7天）
            logger.warning(f"historyId expired for user {user.id}, falling back to full sync")
            return self._fallback_full_sync(user)
        raise
```

#### 2. 批量请求错误处理（429/5xx风险）
```python
def get_messages_batch_with_retry(self, user: User, message_ids: List[str]) -> List[Dict[str, Any]]:
    """批量获取邮件，带重试机制"""
    for batch in self._chunk_list(message_ids, 50):  # 每批50个
        retry_count = 0
        while retry_count <= 1:  # 最多重试1次
            try:
                return self._batch_request(user, batch)
            except (HttpError) as e:
                if e.resp.status in [429, 500, 502, 503, 504] and retry_count == 0:
                    retry_count += 1
                    time.sleep(2 ** retry_count)  # 指数退避
                    continue
                else:
                    # 两次失败则跳过并记录
                    logger.error(f"Batch request failed after retry for user {user.id}: {e}")
                    return []  # 返回空列表，不阻塞整个同步
```

#### 3. 网络超时控制（并发阻塞风险）
```python
def _batch_request(self, user: User, message_ids: List[str]) -> List[Dict[str, Any]]:
    """执行批量请求，带超时控制"""
    service = self._get_gmail_service(user)
    
    # 设置5秒超时
    import httpx
    with httpx.Client(timeout=5.0) as client:
        # Gmail API批量请求实现
        # 批量<=100封时，5秒超时影响可忽略
        pass
```

#### 4. 数据库唯一约束（防重复风险）
```python
# 在Email模型中添加联合唯一约束
class Email(Base):
    # ... 现有字段
    __table_args__ = (
        UniqueConstraint('gmail_id', 'user_id', name='_gmail_user_uc'),
    )

def bulk_upsert_emails(self, db: Session, emails: List[Email]) -> Dict[str, int]:
    """批量插入/更新，处理唯一约束冲突"""
    stats = {'new': 0, 'updated': 0, 'errors': 0}
    
    for email in emails:
        try:
            # 使用ON CONFLICT DO UPDATE (PostgreSQL)
            # 或类似的upsert操作
            db.merge(email)  # merge会处理重复
            stats['new'] += 1
        except IntegrityError:
            db.rollback()
            # 尝试更新现有记录
            existing = db.query(Email).filter(
                Email.gmail_id == email.gmail_id,
                Email.user_id == email.user_id
            ).first()
            if existing:
                # 更新字段
                stats['updated'] += 1
            else:
                stats['errors'] += 1
    
    return stats
```

## Tests

### 单元测试

#### 1. Gmail服务层测试（含专家建议的风险测试）
```python
class TestGmailServiceOptimized:
    def test_fetch_changed_msg_ids_success(self):
        """测试成功获取历史变更"""
        # 模拟history API返回数据
        # 验证返回的messageId列表和historyId正确
    
    def test_fetch_changed_msg_ids_expired_404(self):
        """测试historyId过期自动fallback（专家建议）"""
        # 模拟404错误响应（>7天过期）
        # 验证自动调用_fallback_full_sync()
        # 验证不抛出异常，正常返回结果
    
    def test_get_messages_batch_with_retry_success(self):
        """测试批量获取邮件成功"""
        # 测试获取少于50个邮件
        # 测试获取正好50个邮件
        # 验证5秒超时设置生效
    
    def test_get_messages_batch_retry_429_then_success(self):
        """测试429限流重试成功（专家建议）"""
        # 第1次请求返回429
        # 第2次请求成功
        # 验证指数退避延迟
        # 验证最终返回正确结果
    
    def test_get_messages_batch_retry_twice_then_skip(self):
        """测试两次失败后跳过（专家建议）"""
        # 两次请求都失败（5xx错误）
        # 验证记录错误日志
        # 验证返回空列表而不阻塞同步
    
    def test_batch_request_timeout_control(self):
        """测试网络超时控制（专家建议）"""
        # 模拟网络延迟超过5秒
        # 验证请求被正确超时终止
        # 验证不阻塞整个同步流程
```

#### 2. 同步服务层测试（含数据完整性测试）
```python
class TestEmailSyncServiceOptimized:
    def test_sync_emails_optimized_no_changes(self):
        """测试无变更的增量同步"""
        # 设置用户有有效的last_history_id
        # 模拟history API返回空变更
        # 验证同步时间短、API调用少
    
    def test_sync_emails_optimized_with_changes(self):
        """测试有变更的增量同步"""
        # 模拟history API返回5个变更邮件
        # 验证只获取这5个邮件的详情
        # 验证数据库正确更新
    
    def test_sync_emails_optimized_fallback_to_full(self):
        """测试回退到全量同步（专家建议）"""
        # 模拟historyId过期404
        # 验证自动触发_fallback_full_sync()
        # 验证同步继续进行而不报错
        # 验证更新用户的last_history_id
    
    def test_bulk_upsert_emails_with_duplicates(self):
        """测试批量插入处理重复数据（专家建议）"""
        # 准备包含重复gmail_id的邮件列表
        # 验证联合唯一约束生效
        # 验证重复邮件被正确更新而不是插入
        # 验证返回正确的统计信息
    
    def test_process_messages_batch_partial_failure(self):
        """测试批量处理部分失败不阻塞（专家建议）"""
        # 模拟某些批次失败
        # 验证成功的批次正常处理
        # 验证失败批次被跳过并记录日志
        # 验证整个同步流程继续
    
    def test_incremental_sync_by_history_success(self):
        """测试History API增量同步成功"""
        # 验证正确调用fetch_changed_msg_ids
        # 验证批量获取邮件详情（带重试）
        # 验证bulk_upsert_emails处理重复
        # 验证更新last_history_id
```

#### 3. 性能监控测试
```python
class TestSyncPerformanceMonitor:
    def test_stage_timing(self):
        """测试阶段计时功能"""
        # 测试开始和结束阶段计时
        # 验证时间统计正确
    
    def test_api_call_counting(self):
        """测试API调用计数"""
        # 测试记录API调用次数
        # 验证统计准确
    
    def test_performance_report(self):
        """测试性能报告生成"""
        # 验证报告包含所有必要信息
        # 验证格式正确
```

### 集成测试

#### 1. 端到端同步测试
```python
class TestOptimizedSyncIntegration:
    def test_full_sync_flow_no_previous_history(self):
        """测试首次同步的完整流程"""
        # 新用户没有last_history_id
        # 验证执行全量同步
        # 验证设置last_history_id
    
    def test_incremental_sync_flow_with_changes(self):
        """测试增量同步完整流程"""
        # 用户有有效的last_history_id
        # 模拟Gmail有新邮件
        # 验证只同步新邮件
    
    def test_sync_today_api_endpoint(self):
        """测试 /gmail/sync/today 端点"""
        # 验证API端点调用优化后的同步方法
        # 验证返回正确的性能统计
```

### 性能测试

#### 1. 同步时间对比测试
```python
class TestSyncPerformance:
    def test_sync_time_no_changes(self):
        """测试无变更时的同步时间"""
        # 基准测试：原始方法的同步时间
        # 优化测试：新方法的同步时间
        # 验证：新方法时间 < 原方法时间 / 5
    
    def test_sync_time_with_few_changes(self):
        """测试少量变更时的同步时间"""
        # 模拟3个新邮件
        # 对比原方法和新方法的时间
        # 验证显著的性能提升
    
    def test_api_call_reduction(self):
        """测试API调用次数减少"""
        # 统计原方法的API调用次数
        # 统计新方法的API调用次数
        # 验证新方法调用次数显著减少
```

### 边界测试

#### 1. 异常情况测试
```python
class TestSyncEdgeCases:
    def test_network_timeout_handling(self):
        """测试网络超时处理"""
        # 模拟网络超时
        # 验证正确的错误处理和重试
    
    def test_rate_limit_handling(self):
        """测试API限流处理"""
        # 模拟API限流响应
        # 验证指数退避重试
    
    def test_large_history_changes(self):
        """测试大量历史变更"""
        # 模拟1000个变更邮件
        # 验证正确的分批处理
        # 验证内存使用合理
    
    def test_corrupted_history_id(self):
        """测试损坏的historyId"""
        # 模拟无效的historyId
        # 验证正确回退到全量同步
```

### 测试数据准备

1. **Mock Gmail API响应**：准备各种API响应的测试数据
2. **测试用户数据**：创建有不同history状态的测试用户
3. **性能基准数据**：记录优化前的性能指标作为对比基准

### 测试执行策略

1. **TDD开发流程**：先写测试，再实现功能
2. **持续集成**：每次提交都运行全部测试
3. **性能回归测试**：定期运行性能测试，防止性能退化
4. **真实环境测试**：在staging环境测试真实的Gmail API交互