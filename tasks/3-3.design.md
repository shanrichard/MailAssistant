# Design 3-3 - 优化 EmailProcessorAgent 实现

## 任务拆分说明

由于优化涉及多个独立模块，任务被拆分为5个子任务：
1. 3-3-1: 修复 Prompt 隔离性问题（独立且关键）
2. 3-3-2: 实现 LLM 缓存机制（独立的性能优化）
3. 3-3-3: 增强 Tool 异常处理（涉及所有tools的修改）
4. 3-3-4: 实现日报幂等性和审计日志（需要数据库改动）
5. 3-3-5: 优化能力声明和配置外部化（独立的重构）

## Requirements

基于朋友的专业建议，优化 EmailProcessorAgent 的实现，解决以下问题：

1. **Prompt 定制的隔离性问题**
   - 当前使用浅拷贝修改父类 prompt，会影响所有实例
   - 需要实现深拷贝或使用函数式 prompt 构建

2. **LLM 实例缓存机制**
   - 避免重复初始化 LLM 实例的开销
   - 参考 ConversationHandler 的缓存实现

3. **Tool 异常处理增强**
   - 实现统一的异常包装器
   - 避免单个 tool 错误导致整个任务失败

4. **调度友好度优化**
   - 实现幂等性：同一天多次运行不会生成重复日报
   - 支持基于 (user_id + date) 的状态记录

5. **日志和审计功能**
   - 记录每次分析的结果
   - 便于问题排查和性能监控

6. **能力声明结构化**
   - 将能力列表改为结构化数据
   - 支持前端动态渲染

## Solution

### 1. Prompt 定制隔离性改进

#### 1.1 使用深拷贝方案
```python
from copy import deepcopy

def _build_system_prompt(self):
    """构建EmailProcessor特定的系统prompt - 使用深拷贝"""
    base_prompt = super()._build_system_prompt()
    
    # 深拷贝整个prompt以避免修改父类
    prompt_copy = deepcopy(base_prompt)
    
    # 获取当前系统消息内容
    system_content = prompt_copy.messages[0].content
    
    # 构建增强的系统消息
    enhanced_content = f"""{system_content}

你是专门负责邮件分析和处理的智能代理。你的专业领域包括：
[原有的邮件处理指导内容...]
"""
    
    # 更新拷贝后的消息
    prompt_copy.messages[0] = SystemMessage(content=enhanced_content)
    
    return prompt_copy
```

#### 1.2 更优雅的函数式方案
```python
def _build_system_prompt(self):
    """构建EmailProcessor特定的系统prompt - 函数式方案"""
    base_template = super()._build_system_prompt()
    
    # 使用 partial 注入特定的系统消息
    email_processor_instructions = """
你是专门负责邮件分析和处理的智能代理...[具体内容]
"""
    
    return ChatPromptTemplate.from_messages([
        ("system", "{base_system}\n\n{email_instructions}"),
        MessagesPlaceholder(variable_name="chat_history", optional=True),
        ("user", "{input}"),
        MessagesPlaceholder(variable_name="agent_scratchpad")
    ]).partial(
        base_system=base_template.messages[0].content,
        email_instructions=email_processor_instructions
    )
```

### 2. LLM 实例缓存机制

```python
class EmailProcessorAgent(BaseAgent):
    """邮件处理Agent - 无状态，专注于邮件分析和日报生成"""
    
    # 类级别 LLM 缓存
    _llm_cache = {}
    _cache_lock = threading.Lock()
    
    def _create_llm(self):
        """创建或获取缓存的LLM实例"""
        cache_key = (
            settings.llm.default_provider,
            self._get_default_model(),
            self._get_temperature()
        )
        
        with self._cache_lock:
            if cache_key not in self._llm_cache:
                self._llm_cache[cache_key] = llm_provider_manager.get_llm(
                    provider=cache_key[0],
                    model=cache_key[1],
                    temperature=cache_key[2]
                )
                logger.info(f"Created new LLM instance for cache key: {cache_key}")
            
            return self._llm_cache[cache_key]
    
    @classmethod
    def clear_llm_cache(cls):
        """清理LLM缓存"""
        with cls._cache_lock:
            cls._llm_cache.clear()
            logger.info("EmailProcessorAgent LLM cache cleared")
```

### 3. Tool 异常处理增强

#### 3.1 创建统一的异常包装器
```python
# 在 email_tools.py 中添加
from functools import wraps
from typing import Callable, Any

def safe_tool_wrapper(tool_func: Callable) -> Callable:
    """统一的tool异常包装器"""
    @wraps(tool_func)
    def wrapper(*args, **kwargs) -> str:
        tool_name = tool_func.__name__
        try:
            result = tool_func(*args, **kwargs)
            # 确保结果是字符串
            if not isinstance(result, str):
                result = json.dumps(result, ensure_ascii=False)
            return result
        except json.JSONDecodeError as e:
            logger.error(f"Tool {tool_name} JSON error", exc_info=True)
            return json.dumps({
                "status": "error",
                "tool": tool_name,
                "error_type": "json_decode_error",
                "message": f"JSON解析错误: {str(e)}",
                "timestamp": datetime.now().isoformat()
            }, ensure_ascii=False)
        except Exception as e:
            logger.error(f"Tool {tool_name} failed", exc_info=True)
            return json.dumps({
                "status": "error",
                "tool": tool_name,
                "error_type": type(e).__name__,
                "message": f"工具执行失败: {str(e)}",
                "timestamp": datetime.now().isoformat()
            }, ensure_ascii=False)
    
    # 保留tool的元数据
    wrapper.name = tool_name
    wrapper.description = getattr(tool_func, 'description', '')
    
    return wrapper
```

#### 3.2 应用到所有tools
```python
def create_email_tools(user_id: str, db_session, user_context: Dict[str, Any]):
    """创建邮件处理工具集"""
    
    @tool
    @safe_tool_wrapper
    def sync_emails(days: int = 1) -> str:
        # 原有实现...
        
    @tool
    @safe_tool_wrapper
    def analyze_email(email_id: str) -> str:
        # 原有实现...
    
    # 其他tools同理...
```

### 4. 调度友好度优化 - 幂等性实现

#### 4.1 添加日报状态表
```python
# models/daily_report_log.py
class DailyReportLog(Base):
    """日报生成日志表"""
    __tablename__ = "daily_report_logs"
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    user_id = Column(String, ForeignKey("users.id"), nullable=False)
    report_date = Column(Date, nullable=False)
    report_content = Column(JSON, nullable=False)
    status = Column(String, default="completed")  # completed, failed, processing
    created_at = Column(DateTime(timezone=True), default=lambda: datetime.now(timezone.utc))
    updated_at = Column(DateTime(timezone=True), onupdate=lambda: datetime.now(timezone.utc))
    
    # 唯一索引保证幂等性
    __table_args__ = (
        UniqueConstraint('user_id', 'report_date', name='_user_date_uc'),
    )
```

#### 4.2 修改 generate_daily_report tool
```python
@tool
@safe_tool_wrapper
def generate_daily_report(target_date: Optional[str] = None) -> str:
    """生成指定日期的邮件日报 - 支持幂等性"""
    try:
        if target_date:
            report_date = datetime.strptime(target_date, "%Y-%m-%d").date()
        else:
            report_date = date.today()
        
        # 检查是否已存在日报
        existing_report = db_session.query(DailyReportLog).filter(
            DailyReportLog.user_id == user_id,
            DailyReportLog.report_date == report_date,
            DailyReportLog.status == "completed"
        ).first()
        
        if existing_report:
            logger.info(f"Daily report already exists for {user_id} on {report_date}")
            return json.dumps({
                "status": "success",
                "message": "日报已存在",
                "report_id": str(existing_report.id),
                "created_at": existing_report.created_at.isoformat(),
                **existing_report.report_content
            }, ensure_ascii=False)
        
        # 创建处理中的记录（防止并发）
        report_log = DailyReportLog(
            user_id=user_id,
            report_date=report_date,
            status="processing",
            report_content={}
        )
        
        try:
            db_session.add(report_log)
            db_session.commit()
        except IntegrityError:
            # 并发情况下，另一个进程已创建
            db_session.rollback()
            return generate_daily_report(target_date)  # 递归重试
        
        # 生成报告内容（原有逻辑）
        # ... 
        
        # 更新记录
        report_log.report_content = report
        report_log.status = "completed"
        db_session.commit()
        
        return json.dumps({
            **report,
            "report_id": str(report_log.id)
        }, ensure_ascii=False)
        
    except Exception as e:
        if 'report_log' in locals():
            report_log.status = "failed"
            db_session.commit()
        raise
```

### 5. 日志和审计功能增强

#### 5.1 添加分析审计日志
```python
# models/analysis_audit_log.py
class AnalysisAuditLog(Base):
    """邮件分析审计日志"""
    __tablename__ = "analysis_audit_logs"
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    user_id = Column(String, ForeignKey("users.id"), nullable=False)
    email_id = Column(UUID(as_uuid=True), ForeignKey("emails.id"))
    operation_type = Column(String)  # analyze, batch_analyze, generate_report
    request_params = Column(JSON)
    response_data = Column(JSON)
    execution_time_ms = Column(Integer)
    status = Column(String)  # success, error
    error_message = Column(Text)
    created_at = Column(DateTime(timezone=True), default=lambda: datetime.now(timezone.utc))
```

#### 5.2 添加审计装饰器
```python
def audit_tool_operation(operation_type: str):
    """审计工具操作的装饰器"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            start_time = time.time()
            audit_log = AnalysisAuditLog(
                user_id=user_id,
                operation_type=operation_type,
                request_params={"args": args, "kwargs": kwargs},
                created_at=datetime.now(timezone.utc)
            )
            
            try:
                result = func(*args, **kwargs)
                audit_log.status = "success"
                audit_log.response_data = json.loads(result) if isinstance(result, str) else result
                return result
            except Exception as e:
                audit_log.status = "error"
                audit_log.error_message = str(e)
                raise
            finally:
                audit_log.execution_time_ms = int((time.time() - start_time) * 1000)
                db_session.add(audit_log)
                db_session.commit()
        
        return wrapper
    return decorator

# 应用到tools
@tool
@safe_tool_wrapper
@audit_tool_operation("email_analysis")
def analyze_email(email_id: str) -> str:
    # 原有实现...
```

### 6. 能力声明结构化

```python
from dataclasses import dataclass
from typing import List, Optional

@dataclass
class AgentCapability:
    """Agent能力描述"""
    name: str
    display_name: str
    description: str
    icon: str
    category: str
    enabled: bool = True
    
class EmailProcessorAgent(BaseAgent):
    
    def get_capabilities(self) -> List[AgentCapability]:
        """获取结构化的Agent能力列表"""
        return [
            AgentCapability(
                name="email_synchronization",
                display_name="邮件同步",
                description="从Gmail同步邮件到本地数据库",
                icon="sync",
                category="data_management"
            ),
            AgentCapability(
                name="email_analysis",
                display_name="邮件分析",
                description="使用AI分析邮件内容和重要性",
                icon="analytics",
                category="intelligence"
            ),
            AgentCapability(
                name="daily_report_generation",
                display_name="日报生成",
                description="生成每日邮件摘要报告",
                icon="description",
                category="reporting"
            ),
            AgentCapability(
                name="batch_processing",
                display_name="批量处理",
                description="批量分析和处理邮件",
                icon="folder_open",
                category="automation"
            ),
            AgentCapability(
                name="importance_assessment",
                display_name="重要性评估",
                description="基于用户偏好评估邮件重要性",
                icon="priority_high",
                category="intelligence"
            ),
            AgentCapability(
                name="business_opportunity_detection",
                display_name="商机识别",
                description="识别邮件中的商业机会",
                icon="business_center",
                category="intelligence"
            ),
            AgentCapability(
                name="content_summarization",
                display_name="内容摘要",
                description="生成邮件内容的简洁摘要",
                icon="summarize",
                category="intelligence"
            ),
            AgentCapability(
                name="sentiment_analysis",
                display_name="情感分析",
                description="分析邮件的情感倾向",
                icon="sentiment_satisfied",
                category="intelligence"
            )
        ]
    
    def get_capabilities_by_category(self) -> Dict[str, List[AgentCapability]]:
        """按类别组织能力"""
        capabilities = self.get_capabilities()
        categorized = {}
        for cap in capabilities:
            if cap.category not in categorized:
                categorized[cap.category] = []
            categorized[cap.category].append(cap)
        return categorized
```

### 7. 配置外部化

```python
# config/agent_prompts.py
EMAIL_PROCESSOR_SYSTEM_PROMPT = """
你是专门负责邮件分析和处理的智能代理。你的专业领域包括：

1. 邮件内容分析和重要性评估
2. 邮件分类和情感分析
3. 商业机会识别
4. 日报生成和数据统计
5. 批量邮件处理和同步

工作原则：
- 始终基于用户偏好进行邮件重要性判断
- 提供详细的分析理由和建议
- 高效处理大量邮件数据
- 生成结构化、有价值的报告内容
- 识别并突出重要信息和机会

可用工具说明：
- sync_emails: 同步Gmail邮件到本地
- analyze_email: 深度分析单封邮件
- generate_daily_report: 生成每日邮件报告
- batch_analyze_emails: 批量分析邮件

请根据用户请求，智能选择合适的工具组合来完成任务。
"""

# 在 EmailProcessorAgent 中使用
from ..config.agent_prompts import EMAIL_PROCESSOR_SYSTEM_PROMPT
```

## Tests

### 1. 单元测试

```python
# test_email_processor_agent.py

class TestEmailProcessorAgent:
    
    def test_prompt_isolation(self):
        """测试prompt修改不影响其他实例"""
        agent1 = EmailProcessorAgent(user_id="user1", db_session=db)
        agent2 = EmailProcessorAgent(user_id="user2", db_session=db)
        
        # 获取各自的prompt
        prompt1 = agent1._build_system_prompt()
        prompt2 = agent2._build_system_prompt()
        
        # 验证是不同的对象
        assert id(prompt1) != id(prompt2)
        assert id(prompt1.messages[0]) != id(prompt2.messages[0])
    
    def test_llm_cache_reuse(self):
        """测试LLM缓存复用"""
        # 清空缓存
        EmailProcessorAgent.clear_llm_cache()
        
        # 创建多个相同配置的agent
        agents = [
            EmailProcessorAgent(user_id=f"user{i}", db_session=db)
            for i in range(3)
        ]
        
        # 验证LLM实例被复用
        assert len(EmailProcessorAgent._llm_cache) == 1
        assert all(id(a.llm) == id(agents[0].llm) for a in agents)
    
    def test_tool_error_handling(self):
        """测试tool异常处理"""
        agent = EmailProcessorAgent(user_id="test", db_session=db)
        
        # 模拟tool错误
        with patch('app.services.email_sync_service.sync_user_emails') as mock:
            mock.side_effect = Exception("Network error")
            
            result = agent.tools[0].func(days=1)  # sync_emails
            result_data = json.loads(result)
            
            assert result_data["status"] == "error"
            assert "Network error" in result_data["message"]
            assert result_data["tool"] == "sync_emails"
    
    def test_daily_report_idempotency(self):
        """测试日报生成的幂等性"""
        agent = EmailProcessorAgent(user_id="test", db_session=db)
        
        # 第一次生成
        result1 = generate_daily_report(target_date="2025-01-15")
        data1 = json.loads(result1)
        assert data1["status"] == "success"
        report_id1 = data1.get("report_id")
        
        # 第二次生成（应返回相同结果）
        result2 = generate_daily_report(target_date="2025-01-15")
        data2 = json.loads(result2)
        assert data2["status"] == "success"
        assert data2["message"] == "日报已存在"
        assert data2.get("report_id") == report_id1
    
    def test_concurrent_report_generation(self):
        """测试并发生成日报"""
        import concurrent.futures
        
        def generate_report():
            agent = EmailProcessorAgent(user_id="test", db_session=db)
            return generate_daily_report(target_date="2025-01-16")
        
        # 并发执行
        with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:
            futures = [executor.submit(generate_report) for _ in range(5)]
            results = [f.result() for f in futures]
        
        # 验证只生成了一份报告
        report_ids = [json.loads(r).get("report_id") for r in results]
        assert len(set(report_ids)) == 1
    
    def test_audit_logging(self):
        """测试审计日志记录"""
        agent = EmailProcessorAgent(user_id="test", db_session=db)
        
        # 执行分析
        email_id = "test-email-id"
        result = analyze_email(email_id)
        
        # 检查审计日志
        audit_log = db.query(AnalysisAuditLog).filter(
            AnalysisAuditLog.user_id == "test",
            AnalysisAuditLog.operation_type == "email_analysis"
        ).first()
        
        assert audit_log is not None
        assert audit_log.status == "success"
        assert audit_log.execution_time_ms > 0
        assert audit_log.request_params["kwargs"]["email_id"] == email_id
    
    def test_structured_capabilities(self):
        """测试结构化能力声明"""
        agent = EmailProcessorAgent(user_id="test", db_session=db)
        
        capabilities = agent.get_capabilities()
        assert len(capabilities) == 8
        assert all(isinstance(c, AgentCapability) for c in capabilities)
        
        # 测试按类别分组
        by_category = agent.get_capabilities_by_category()
        assert "intelligence" in by_category
        assert "data_management" in by_category
        assert len(by_category["intelligence"]) > 0
```

### 2. 集成测试

```python
# test_email_processor_integration.py

class TestEmailProcessorIntegration:
    
    async def test_full_workflow(self):
        """测试完整工作流：同步→分析→生成日报"""
        agent = EmailProcessorAgent(user_id="test", db_session=db)
        
        # 1. 同步邮件
        sync_result = await agent.process("同步最近3天的邮件")
        assert "成功" in sync_result
        
        # 2. 批量分析
        analysis_result = await agent.process("分析所有未处理的邮件")
        assert "分析完成" in analysis_result
        
        # 3. 生成日报
        report_result = await agent.process("生成今天的邮件日报")
        assert "日报" in report_result
        
        # 4. 再次生成（测试幂等性）
        report_result2 = await agent.process("生成今天的邮件日报")
        assert "已存在" in report_result2
    
    async def test_error_recovery(self):
        """测试错误恢复能力"""
        agent = EmailProcessorAgent(user_id="test", db_session=db)
        
        # 模拟网络错误
        with patch('app.services.gmail_service.get_messages') as mock:
            mock.side_effect = Exception("Network timeout")
            
            result = await agent.process("同步邮件")
            assert "失败" in result or "错误" in result
            
        # 恢复后重试
        result = await agent.process("同步邮件")
        assert "成功" in result
```

### 3. 性能测试

```python
# test_email_processor_performance.py

class TestEmailProcessorPerformance:
    
    def test_llm_cache_performance(self):
        """测试LLM缓存的性能提升"""
        import time
        
        # 清空缓存
        EmailProcessorAgent.clear_llm_cache()
        
        # 首次创建（无缓存）
        start = time.time()
        agent1 = EmailProcessorAgent(user_id="user1", db_session=db)
        first_time = time.time() - start
        
        # 第二次创建（有缓存）
        start = time.time()
        agent2 = EmailProcessorAgent(user_id="user2", db_session=db)
        second_time = time.time() - start
        
        # 缓存应该显著加快初始化
        assert second_time < first_time * 0.1
    
    def test_batch_processing_performance(self):
        """测试批量处理性能"""
        # 创建100封测试邮件
        create_test_emails(100)
        
        agent = EmailProcessorAgent(user_id="test", db_session=db)
        
        start = time.time()
        result = batch_analyze_emails(days=1)
        elapsed = time.time() - start
        
        result_data = json.loads(result)
        
        # 性能指标
        assert result_data["analyzed_count"] == 100
        assert elapsed < 60  # 应在1分钟内完成100封邮件
        
        # 检查审计日志
        logs = db.query(AnalysisAuditLog).filter(
            AnalysisAuditLog.operation_type == "batch_analyze"
        ).all()
        
        avg_time = sum(log.execution_time_ms for log in logs) / len(logs)
        assert avg_time < 600  # 平均每封邮件不超过600ms
```

### 4. 调度兼容性测试

```python
# test_scheduler_compatibility.py

class TestSchedulerCompatibility:
    
    def test_celery_task_integration(self):
        """测试与Celery任务的集成"""
        from app.tasks import process_daily_reports
        
        # 模拟定时任务
        result = process_daily_reports.apply_async(
            args=["test_user"],
            kwargs={"date": "2025-01-15"}
        )
        
        # 等待完成
        task_result = result.get(timeout=30)
        
        assert task_result["status"] == "success"
        
        # 再次执行（测试幂等性）
        result2 = process_daily_reports.apply_async(
            args=["test_user"],
            kwargs={"date": "2025-01-15"}
        )
        
        task_result2 = result2.get(timeout=5)  # 应该很快返回
        assert task_result2["message"] == "日报已存在"
```

### 5. 监控和告警测试

```python
# test_monitoring.py

class TestMonitoring:
    
    def test_metrics_collection(self):
        """测试指标收集"""
        from app.monitoring import metrics
        
        agent = EmailProcessorAgent(user_id="test", db_session=db)
        
        # 执行操作
        analyze_email("test-email")
        
        # 验证指标
        assert metrics.email_analysis_total > 0
        assert metrics.email_analysis_duration.count > 0
        assert metrics.email_analysis_errors.count >= 0
    
    def test_health_check(self):
        """测试健康检查"""
        agent = EmailProcessorAgent(user_id="test", db_session=db)
        
        health_status = agent.health_check()
        
        assert health_status["status"] == "healthy"
        assert "llm_cache_size" in health_status
        assert "last_analysis_time" in health_status
```