# Design 3-2-4 - Checkpointer 和消息裁剪优化

## Requirements

### Checkpointer 优化需求
- 评估是否需要将 InMemorySaver 提升为类级别或外部单例
- 明确跨会话历史共享策略
- 优化内存使用

### 消息裁剪需求（可选）
- 防止长对话超过 token 限制
- 引入 MessagePrunerNode 自动裁剪历史消息
- 保持对话连贯性

## Solution

### 1. Checkpointer 策略分析

#### 选项 A：保持实例级别（当前方案）
- 每个 ConversationHandler 实例有独立的 checkpointer
- 优点：隔离性好，无需考虑并发
- 缺点：内存占用较高

#### 选项 B：类级别单例
- 所有实例共享一个 checkpointer
- 优点：内存效率高
- 缺点：需要处理并发访问

#### 选项 C：外部管理的 checkpointer 池
- 根据用户/会话创建 checkpointer 池
- 优点：平衡内存和隔离性
- 缺点：实现复杂

### 2. 推荐方案：优化的实例级别 checkpointer

```python
from langgraph.checkpoint.memory import InMemorySaver
from typing import Optional
import weakref

class ConversationHandler(StatefulAgent):
    # 使用弱引用缓存 checkpointer，允许垃圾回收
    _checkpointer_cache = weakref.WeakValueDictionary()
    
    def __init__(self, user_id: str, db_session, user=None):
        super().__init__(user_id, db_session, user)
        
        # 为每个用户创建独立的 checkpointer
        checkpointer_key = f"user_{self.user_id}"
        
        if checkpointer_key not in self._checkpointer_cache:
            self._checkpointer_cache[checkpointer_key] = InMemorySaver()
        
        self.checkpointer = self._checkpointer_cache[checkpointer_key]
        
        # ... 其余初始化代码
```

### 3. 消息裁剪实现

#### 3.1 基础裁剪策略

```python
from langgraph.graph import StateGraph
from langgraph.graph.message import MessageGraph

def _create_agent_with_pruning(self, llm, tools, max_messages: int = 50):
    """创建带消息裁剪的 agent"""
    # 创建基础 agent
    base_agent = create_react_agent(
        model=llm,
        tools=tools,
        prompt=self._build_prompt,
        checkpointer=self.checkpointer
    )
    
    # 创建自定义裁剪逻辑
    def prune_messages(state: AgentState) -> AgentState:
        """裁剪消息，保留系统消息和最近的 N 条消息"""
        messages = state["messages"]
        
        if len(messages) <= max_messages:
            return state
        
        # 保留系统消息
        system_messages = [m for m in messages if isinstance(m, SystemMessage)]
        other_messages = [m for m in messages if not isinstance(m, SystemMessage)]
        
        # 保留最近的消息
        pruned_messages = system_messages + other_messages[-(max_messages - len(system_messages)):]
        
        return {
            **state,
            "messages": pruned_messages
        }
    
    # 构建带裁剪的图
    graph = StateGraph(AgentState)
    graph.add_node("prune", prune_messages)
    graph.add_node("agent", base_agent)
    
    graph.add_edge("prune", "agent")
    graph.set_entry_point("prune")
    
    return graph.compile()
```

#### 3.2 智能裁剪策略

```python
def _smart_message_pruning(self, messages: List[BaseMessage], 
                          max_tokens: int = 3000) -> List[BaseMessage]:
    """基于 token 数量的智能裁剪"""
    from tiktoken import encoding_for_model
    
    # 获取编码器（缓存以提高性能）
    if not hasattr(self, '_encoder'):
        self._encoder = encoding_for_model(self._get_default_model())
    
    # 计算每条消息的 token 数
    message_tokens = []
    for msg in messages:
        tokens = len(self._encoder.encode(msg.content))
        message_tokens.append((msg, tokens))
    
    # 保留系统消息和最新消息，直到达到 token 限制
    result = []
    current_tokens = 0
    
    # 先添加系统消息
    for msg, tokens in message_tokens:
        if isinstance(msg, SystemMessage):
            result.append(msg)
            current_tokens += tokens
    
    # 从后往前添加其他消息
    for msg, tokens in reversed(message_tokens):
        if not isinstance(msg, SystemMessage):
            if current_tokens + tokens <= max_tokens:
                result.insert(len([m for m in result if isinstance(m, SystemMessage)]), msg)
                current_tokens += tokens
            else:
                break
    
    return result
```

### 4. 配置化的裁剪策略

```python
# 在 settings.py 中添加配置
class ConversationSettings(BaseSettings):
    # 消息裁剪配置
    message_pruning_enabled: bool = True
    max_messages_count: int = 50
    max_tokens_count: int = 3000
    pruning_strategy: str = "count"  # "count" 或 "tokens"
    
    # Checkpointer 配置
    checkpointer_strategy: str = "per_user"  # "per_instance", "per_user", "singleton"
    checkpointer_ttl: int = 3600  # 缓存过期时间（秒）
```

### 5. 完整的初始化方法

```python
def __init__(self, user_id: str, db_session, user=None):
    super().__init__(user_id, db_session, user)
    
    # 初始化 checkpointer
    self.checkpointer = self._get_checkpointer()
    
    # 获取或创建 LLM
    cache_key = (
        settings.llm.default_provider,
        self._get_default_model(),
        self._get_temperature()
    )
    
    with self._cache_lock:
        if cache_key not in self._llm_cache:
            self._llm_cache[cache_key] = self.llm
    
    # 根据配置决定是否启用消息裁剪
    if settings.conversation.message_pruning_enabled:
        self.graph_agent = self._create_agent_with_pruning(
            llm=self._llm_cache[cache_key],
            tools=self.tools,
            max_messages=settings.conversation.max_messages_count
        )
    else:
        self.graph_agent = create_react_agent(
            model=self._llm_cache[cache_key],
            tools=self.tools,
            prompt=self._build_prompt,
            checkpointer=self.checkpointer
        )

def _get_checkpointer(self):
    """根据配置策略获取 checkpointer"""
    strategy = settings.conversation.checkpointer_strategy
    
    if strategy == "per_instance":
        return InMemorySaver()
    elif strategy == "per_user":
        key = f"user_{self.user_id}"
        if key not in self._checkpointer_cache:
            self._checkpointer_cache[key] = InMemorySaver()
        return self._checkpointer_cache[key]
    elif strategy == "singleton":
        if not hasattr(self.__class__, '_global_checkpointer'):
            self.__class__._global_checkpointer = InMemorySaver()
        return self._global_checkpointer
    else:
        raise ValueError(f"Unknown checkpointer strategy: {strategy}")
```

## Tests

### 单元测试

1. **test_checkpointer_strategies**
   ```python
   def test_checkpointer_strategies():
       """测试不同的 checkpointer 策略"""
       # 测试 per_user 策略
       settings.conversation.checkpointer_strategy = "per_user"
       handler1 = ConversationHandler("user1", db_session)
       handler2 = ConversationHandler("user1", db_session)
       handler3 = ConversationHandler("user2", db_session)
       
       assert handler1.checkpointer is handler2.checkpointer
       assert handler1.checkpointer is not handler3.checkpointer
   ```

2. **test_message_pruning**
   ```python
   async def test_message_pruning():
       """测试消息裁剪功能"""
       settings.conversation.message_pruning_enabled = True
       settings.conversation.max_messages_count = 10
       
       handler = ConversationHandler("test_user", db_session)
       
       # 发送多条消息
       for i in range(20):
           await handler.stream_response(f"Message {i}", "session_1")
       
       # 验证消息数量被限制
       # 需要访问内部状态来验证
   ```

3. **test_token_based_pruning**
   ```python
   def test_token_based_pruning():
       """测试基于 token 的裁剪"""
       handler = ConversationHandler("test_user", db_session)
       
       # 创建不同长度的消息
       messages = [
           SystemMessage(content="System prompt"),
           HumanMessage(content="Short"),
           AIMessage(content="A" * 1000),  # 长消息
           HumanMessage(content="Latest message")
       ]
       
       pruned = handler._smart_message_pruning(messages, max_tokens=500)
       
       # 验证保留了系统消息和最新消息
       assert any(isinstance(m, SystemMessage) for m in pruned)
       assert pruned[-1].content == "Latest message"
   ```

### 性能测试

1. **test_memory_usage_with_pruning**
   - 测试启用/禁用裁剪时的内存使用差异
   - 验证长对话场景下的内存稳定性

2. **test_checkpointer_performance**
   - 比较不同 checkpointer 策略的性能
   - 测量并发访问时的延迟

### 集成测试

1. **test_long_conversation_handling**
   ```python
   async def test_long_conversation_handling():
       """测试长对话处理"""
       handler = ConversationHandler("test_user", db_session)
       
       # 模拟200轮对话
       for i in range(200):
           response = await handler.stream_response(
               f"Question {i}: Tell me about topic {i}", 
               "long_session"
           )
           # 收集响应
       
       # 验证系统仍然响应正常
       final_response = await handler.stream_response(
           "What was my first question?", 
           "long_session"
       )
       
       # 验证能够记住早期上下文（如果在裁剪范围内）
   ```

## 验收标准

- [ ] Checkpointer 策略可配置且正常工作
- [ ] 消息裁剪不影响对话质量
- [ ] 长对话场景下内存使用稳定
- [ ] 裁剪后的对话仍然连贯
- [ ] 性能符合预期（无明显延迟增加）