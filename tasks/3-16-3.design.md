# Design 3-16-3 - é›†æˆ Agent æœåŠ¡å’Œå¯¹è¯æµç¨‹

## Requirements

### èƒŒæ™¯
åœ¨å‰ä¸¤ä¸ªå­ä»»åŠ¡ä¸­ï¼Œæˆ‘ä»¬å·²ç»æˆåŠŸé‡å»ºäº† Socket.IO åŸºç¡€è®¾æ–½ï¼ˆ3-16-1ï¼‰å’Œæ¢å¤äº†å‰ç«¯ WebSocket è¿æ¥ï¼ˆ3-16-2ï¼‰ã€‚ç°åœ¨éœ€è¦å°†ç°æœ‰çš„ Agent æœåŠ¡æ¶æ„é›†æˆåˆ°è¿™ä¸ª WebSocket é€šä¿¡å±‚ï¼Œä½¿èŠå¤©åŠŸèƒ½çœŸæ­£å…·å¤‡ AI å¯¹è¯èƒ½åŠ›ã€‚

### æ ¸å¿ƒéœ€æ±‚

1. **Agent æœåŠ¡é›†æˆ**
   - å°†ç°æœ‰çš„ `ConversationHandler` é›†æˆåˆ° Socket.IO äº‹ä»¶å¤„ç†å™¨ä¸­
   - æ”¯æŒåŸºäº LangGraph çš„æµå¼å¯¹è¯å¤„ç†
   - ä¿æŒç°æœ‰çš„å·¥å…·è°ƒç”¨å’Œ Agent åä½œæœºåˆ¶

2. **å®æ—¶æµå¼å“åº”**
   - å®ç° Agent å“åº”çš„åˆ†å—æµå¼ä¼ è¾“
   - æ”¯æŒå·¥å…·è°ƒç”¨çŠ¶æ€çš„å®æ—¶å¹¿æ’­
   - æ”¯æŒ Agent æ€è€ƒè¿‡ç¨‹çš„å¯è§†åŒ–å±•ç¤º

3. **ä¼šè¯ç®¡ç†å¢å¼º**
   - å°† Socket è¿æ¥ä¸ç”¨æˆ·ä¼šè¯ç»‘å®š
   - å®ç°å¯¹è¯å†å²çš„æŒä¹…åŒ–ç®¡ç†
   - æ”¯æŒå¤šä¼šè¯å¹¶å‘å¤„ç†

4. **å·¥å…·è°ƒç”¨å¯è§†åŒ–**
   - å®æ—¶æ˜¾ç¤ºå·¥å…·è°ƒç”¨å¼€å§‹ã€è¿›è¡Œä¸­ã€å®ŒæˆçŠ¶æ€
   - å±•ç¤ºå·¥å…·æ‰§è¡Œç»“æœ
   - å¤„ç†å·¥å…·è°ƒç”¨å¼‚å¸¸æƒ…å†µ

### æŠ€æœ¯éœ€æ±‚

1. **åç«¯é›†æˆ**
   - ä¿®æ”¹ `socketio_app.py` ä¸­çš„ `user_message` äº‹ä»¶å¤„ç†å™¨
   - é›†æˆç°æœ‰çš„ `ConversationHandler` å’Œç›¸å…³å·¥å…·é›†
   - å®ç°æµå¼å“åº”çš„ Socket.IO äº‹ä»¶å‘é€

2. **æ¶ˆæ¯æµè®¾è®¡**
   - `user_message`: ç”¨æˆ·è¾“å…¥æ¶ˆæ¯
   - `agent_response_chunk`: Agent å“åº”ç‰‡æ®µ
   - `tool_call_start`: å·¥å…·è°ƒç”¨å¼€å§‹
   - `tool_call_result`: å·¥å…·æ‰§è¡Œç»“æœ
   - `agent_thought`: Agent æ€è€ƒè¿‡ç¨‹
   - `conversation_complete`: å¯¹è¯å®Œæˆ

3. **é”™è¯¯å¤„ç†**
   - Agent æœåŠ¡å¼‚å¸¸çš„ä¼˜é›…å¤„ç†
   - å·¥å…·è°ƒç”¨å¤±è´¥çš„é”™è¯¯ä¼ æ’­
   - ç”¨æˆ·å‹å¥½çš„é”™è¯¯æ¶ˆæ¯æ ¼å¼

4. **æ€§èƒ½è¦æ±‚**
   - Agent å“åº”é¦–å­—èŠ‚æ—¶é—´ < 2s
   - æµå¼å“åº”å»¶è¿Ÿ < 100ms/chunk
   - æ”¯æŒè‡³å°‘ 10 ä¸ªå¹¶å‘ä¼šè¯

### åŠŸèƒ½éœ€æ±‚

1. **åŸºæœ¬å¯¹è¯åŠŸèƒ½**
   - ç”¨æˆ·å‘é€æ¶ˆæ¯ï¼ŒAgent æ™ºèƒ½å“åº”
   - æ”¯æŒä¸Šä¸‹æ–‡æ„ŸçŸ¥çš„å¤šè½®å¯¹è¯
   - ä¿æŒå¯¹è¯å†å²å’ŒçŠ¶æ€

2. **å·¥å…·è°ƒç”¨æ”¯æŒ**
   - æ”¯æŒæ‰€æœ‰ç°æœ‰çš„å¯¹è¯å·¥å…·ï¼ˆæœç´¢é‚®ä»¶ã€è¯»å–æ—¥æŠ¥ç­‰ï¼‰
   - å®æ—¶æ˜¾ç¤ºå·¥å…·è°ƒç”¨è¿›åº¦
   - å±•ç¤ºå·¥å…·æ‰§è¡Œç»“æœ

3. **Agent èƒ½åŠ›å±•ç¤º**
   - å±•ç¤º Agent æ€è€ƒè¿‡ç¨‹
   - æ˜¾ç¤ºå·¥å…·é€‰æ‹©é€»è¾‘
   - æä¾›è°ƒè¯•ä¿¡æ¯ï¼ˆå¼€å‘ç¯å¢ƒï¼‰

### é›†æˆçº¦æŸ

1. **ä»£ç å¤ç”¨**
   - å®Œå…¨é‡ç”¨ç°æœ‰çš„ Agent æ¶æ„
   - ä¸ä¿®æ”¹ç°æœ‰çš„å·¥å…·å®ç°
   - ä¿æŒç°æœ‰çš„æ•°æ®æ¨¡å‹

2. **æ€§èƒ½å½±å“**
   - ä¸å½±å“é‚®ä»¶åŒæ­¥æ€§èƒ½
   - æ§åˆ¶ WebSocket è¿æ¥çš„èµ„æºæ¶ˆè€—
   - ä¼˜åŒ– Agent å®ä¾‹çš„å†…å­˜ä½¿ç”¨

3. **ç”¨æˆ·ä½“éªŒ**
   - ä¿æŒç°æœ‰çš„èŠå¤©ç•Œé¢äº¤äº’é€»è¾‘
   - æ”¯æŒç°æœ‰çš„æ¶ˆæ¯ç±»å‹å’Œæ ¼å¼
   - ä¸å‰ç«¯çŠ¶æ€ç®¡ç†æ— ç¼å¯¹æ¥

## Solution

### ç°æœ‰ä»£ç åˆ†æ

**åç«¯ç°çŠ¶**ï¼š
1. `ConversationHandler` å·²å®Œæ•´å®ç°ï¼ŒåŒ…æ‹¬ï¼š
   - æµå¼å“åº”ï¼š`async def stream_response(message: str, session_id: str)`
   - å·¥å…·è°ƒç”¨å¤„ç†å’Œé”™è¯¯åŒ…è£…
   - æ•°æ®åº“æ¶ˆæ¯å­˜å‚¨ï¼ˆConversationMessageæ¨¡å‹ï¼‰
   - LangGraph é›†æˆå’Œç¼“å­˜ç®¡ç†

2. è®¤è¯ç³»ç»Ÿå·²å®Œå¤‡ï¼š
   - JWT token ç®¡ç†
   - `get_current_user_from_token(token: str, db: Session)` å‡½æ•°å¯ç›´æ¥ç”¨äºSocket.IOè®¤è¯

3. Socket.IO åŸºç¡€è®¾æ–½å·²æ­å»ºï¼š
   - `socketio_app.py` å·²åˆ›å»ºï¼Œä½† `user_message` äº‹ä»¶å¤„ç†å™¨æ˜¯å ä½ç¬¦
   - è¿æ¥ç®¡ç†ã€ä¼šè¯å­˜å‚¨å·²å®ç°

**å‰ç«¯ç°çŠ¶**ï¼š  
1. `authStore.ts` å·²ç®¡ç†tokenï¼Œé€šè¿‡zustand persistæŒä¹…åŒ–
2. `chatStore.ts` å·²å®ç°Socket.IOè¿æ¥ï¼Œä½†ç¼ºå°‘ï¼š
   - è¿æ¥æ—¶çš„è®¤è¯ä¿¡æ¯å‘é€
   - æµå¼äº‹ä»¶ç›‘å¬ï¼ˆåªæœ‰åŸºç¡€çš„ `agent_response`ï¼‰
   
### ä¿®æ­£åçš„æ¶æ„è®¾è®¡

åŸºäºç°æœ‰å®ç°ï¼Œé›†æˆæ–¹æ¡ˆç®€åŒ–ä¸ºï¼š

```
å‰ç«¯ authStore â†’ Socket.IO auth â†’ åç«¯è®¤è¯ â†’ ConversationHandler â†’ æµå¼äº‹ä»¶å¹¿æ’­
```

**æ ¸å¿ƒæ”¹åŠ¨ç‚¹**ï¼š
1. Socket.IOè¿æ¥å¢åŠ è®¤è¯æœºåˆ¶
2. `user_message` äº‹ä»¶å¤„ç†å™¨é›†æˆç°æœ‰ConversationHandler
3. å‰ç«¯å¢åŠ æµå¼äº‹ä»¶ç›‘å¬å™¨

### ä»»åŠ¡é‡æ–°èšç„¦

**å½“å‰é—®é¢˜**ï¼šèŠå¤©åŠŸèƒ½åªè¿”å›æµ‹è¯•å“åº”ï¼Œæ²¡æœ‰çœŸæ­£çš„ AI å¯¹è¯èƒ½åŠ›

**3-16-3 çš„æ ¸å¿ƒç›®æ ‡**ï¼š
1. ğŸ¯ **æœ€æ ¸å¿ƒ**ï¼šè®©èŠå¤©å…·å¤‡çœŸæ­£çš„ AI å¯¹è¯èƒ½åŠ›
2. ğŸ¯ **æ ¸å¿ƒ**ï¼šé›†æˆç°æœ‰çš„ ConversationHandler 
3. ğŸ¯ **æ ¸å¿ƒ**ï¼šæ”¯æŒå·¥å…·è°ƒç”¨ï¼ˆæœç´¢é‚®ä»¶ç­‰ï¼‰
4. ğŸ”§ **ä¼˜åŒ–**ï¼šæŠ€æœ¯ä¸“å®¶å»ºè®®çš„5ä¸ªç”Ÿäº§ç¯å¢ƒé—®é¢˜

### åˆ†é˜¶æ®µå®æ–½æ–¹æ¡ˆ

#### é˜¶æ®µ1ï¼šå®ç°åŸºæœ¬ AI å¯¹è¯åŠŸèƒ½ï¼ˆæœ€å°å¯ç”¨ç‰ˆæœ¬ï¼‰

**ç›®æ ‡**ï¼šæ›¿æ¢æµ‹è¯•å“åº”ä¸ºçœŸæ­£çš„ ConversationHandler å¯¹è¯

**æœ€ç®€å®ç°**ï¼š
```python
# ä¿®æ”¹ user_message äº‹ä»¶å¤„ç†å™¨ï¼ˆæœ€å°å¯ç”¨ç‰ˆæœ¬ï¼‰
from .api.auth import get_current_user_from_token
from .agents.conversation_handler import ConversationHandler
from .core.database import get_db

# ç®€å•çš„å…¨å±€Handlerç¼“å­˜
conversation_handlers = {}

@sio.event
async def user_message(sid: str, data: dict):
    """é›†æˆConversationHandlerå®ç°çœŸæ­£çš„AIå¯¹è¯"""
    try:
        # æš‚æ—¶è·³è¿‡è®¤è¯ï¼Œä½¿ç”¨é»˜è®¤ç”¨æˆ·ï¼ˆåç»­ä¼˜åŒ–ï¼‰
        user_id = "default_user"  # ç®€åŒ–ç‰ˆ
        
        # è·å–æˆ–åˆ›å»ºHandler
        if user_id not in conversation_handlers:
            db_session = next(get_db())
            conversation_handlers[user_id] = ConversationHandler(
                user_id, db_session, None
            )
        
        handler = conversation_handlers[user_id]
        message_content = data.get('content', '')
        session_id = data.get('session_id', 'default')
        
        # ä½¿ç”¨ç°æœ‰çš„æµå¼å“åº”
        async for chunk in handler.stream_response(message_content, session_id):
            event_type = chunk.get('type', 'agent_response_chunk')
            await sio.emit(event_type, chunk, room=sid)
            
    except Exception as e:
        logger.error(f"Message handling error for {sid}: {str(e)}")
        await sio.emit('error', {
            'message': 'æ¶ˆæ¯å¤„ç†å‡ºé”™ï¼Œè¯·ç¨åé‡è¯•'
        }, room=sid)
```

**å‰ç«¯é€‚é…**ï¼š
```typescript
// åœ¨ chatStore.ts ä¸­æ·»åŠ æµå¼äº‹ä»¶ç›‘å¬
socket.on('agent_response_chunk', (data) => {
  // å¤„ç†Agentå“åº”ç‰‡æ®µ
  console.log('Agent chunk:', data);
  get().addMessage({
    id: data.id || uuidv4(),
    type: 'agent',
    content: data.content,
    timestamp: new Date(data.timestamp)
  });
});

socket.on('tool_call_start', (data) => {
  // æ˜¾ç¤ºå·¥å…·è°ƒç”¨çŠ¶æ€
  get().addMessage({
    id: uuidv4(),
    type: 'system',
    content: `æ­£åœ¨æ‰§è¡Œï¼š${data.tool_name}`,
    timestamp: new Date()
  });
});
```

#### é˜¶æ®µ2ï¼šæŠ€æœ¯ä¸“å®¶å»ºè®®çš„ç”Ÿäº§ç¯å¢ƒä¼˜åŒ–

**è¿™äº›ä¼˜åŒ–å¾ˆé‡è¦ï¼Œä½†ä¸å½±å“åŸºæœ¬åŠŸèƒ½ä½¿ç”¨**ï¼š

1. **ğŸ”´ è¿æ¥è®¤è¯**ï¼šæ·»åŠ tokenæ ¡éªŒï¼Œé˜²æ­¢æœªæˆæƒè®¿é—®
2. **ğŸ”´ Handlerç¼“å­˜**ï¼šæŒ‰ç”¨æˆ·+ä¼šè¯åˆ†é”®ï¼Œé˜²æ­¢å¤šç«¯ä¸²è¯  
3. **ğŸ”´ DBä¼šè¯ç®¡ç†**ï¼šç¡®ä¿æ•°æ®åº“è¿æ¥æ­£ç¡®å…³é—­
4. **ğŸŸ¡ å¼‚å¸¸åˆ†ç±»**ï¼šåˆ†ç¦»ä¸åŒç±»å‹çš„é”™è¯¯äº‹ä»¶
5. **ğŸŸ¡ å®Œæ•´äº‹ä»¶ç›‘å¬**ï¼šå‰ç«¯ç›‘å¬æ‰€æœ‰æµå¼äº‹ä»¶ç±»å‹

**å®æ–½ç­–ç•¥**ï¼š
- å…ˆè®©åŸºæœ¬å¯¹è¯åŠŸèƒ½æ­£å¸¸å·¥ä½œ
- å†é€æ­¥åº”ç”¨è¿™äº›æœ€ä½³å®è·µä¼˜åŒ–

#### è¯¦ç»†æŠ€æœ¯æ–¹æ¡ˆ

##### 1. Socket.IO è®¤è¯é›†æˆ

**åç«¯è®¤è¯å®ç°**ï¼š
```python
# ä¿®æ”¹ socketio_app.py çš„ connect äº‹ä»¶
@sio.event
async def connect(sid: str, environ: dict, auth: dict = None):
    """å®¢æˆ·ç«¯è¿æ¥äº‹ä»¶ - å¢åŠ è®¤è¯"""
    try:
        logger.info(f"Client connecting: {sid}")
        
        # æå–è®¤è¯token
        token = None
        if auth and 'token' in auth:
            token = auth['token']
        elif environ.get('HTTP_AUTHORIZATION'):
            # ä»headeræå– Bearer token
            auth_header = environ['HTTP_AUTHORIZATION']
            if auth_header.startswith('Bearer '):
                token = auth_header[7:]
        
        user = None
        if token:
            try:
                from .api.auth import get_current_user_from_token
                from .core.database import get_db
                db = next(get_db())
                user = await get_current_user_from_token(token, db)
                logger.info(f"Authenticated user: {user.email}", user_id=user.id)
            except Exception as e:
                logger.warning(f"Authentication failed for {sid}: {str(e)}")
                # è®¤è¯å¤±è´¥ï¼Œæ‹’ç»è¿æ¥
                await sio.emit('error', {
                    'type': 'authentication_required',
                    'message': 'Authentication failed',
                    'error_details': str(e)
                }, room=sid)
                return False  # æ‹’ç»è¿æ¥
        else:
            logger.info(f"No token provided for {sid}, proceeding as guest")
        
        # å­˜å‚¨ä¼šè¯ä¿¡æ¯
        active_sessions[sid] = {
            'connected_at': time(),
            'user_id': user.id if user else None,
            'user': user,
            'environ': environ,
            'authenticated': user is not None
        }
        
        # å‘é€è¿æ¥ç¡®è®¤
        await sio.emit('connection_established', {
            'status': 'connected',
            'session_id': sid,
            'authenticated': user is not None,
            'user': {
                'id': user.id,
                'email': user.email,
                'name': user.name
            } if user else None,
            'timestamp': time()
        }, room=sid)
        
        logger.info(f"Client connected successfully: {sid}, authenticated: {user is not None}")
        return True
        
    except Exception as e:
        logger.error(f"Connection error for {sid}: {str(e)}")
        return False
```

**å‰ç«¯è®¤è¯å‘é€**ï¼š
```typescript
// ä¿®æ”¹ chatStore.ts çš„ connectWebSocket æ–¹æ³•
connectWebSocket: async () => {
    const { socket: currentSocket } = get();
    
    if (currentSocket && currentSocket.connected) {
        return;
    }

    try {
        console.log('æ­£åœ¨è¿æ¥ Socket.IO...');
        
        // ä» authStore è·å– token
        const authStore = useAuthStore.getState();
        const token = authStore.token;
        
        const socket = io('http://localhost:8000', {
            transports: ['websocket', 'polling'],
            timeout: 10000,
            retries: 3,
            // è®¤è¯æ–¹å¼1ï¼šé€šè¿‡ auth å‚æ•°
            auth: token ? { token } : undefined,
            // è®¤è¯æ–¹å¼2ï¼šé€šè¿‡ extraHeadersï¼ˆä½œä¸ºå¤‡é€‰ï¼‰
            extraHeaders: token ? {
                'Authorization': `Bearer ${token}`
            } : undefined
        });

        // è¿æ¥é”™è¯¯å¤„ç†ï¼ˆåŒ…æ‹¬è®¤è¯å¤±è´¥ï¼‰
        socket.on('connect_error', async (error) => {
            console.error('Socket.IO è¿æ¥é”™è¯¯:', error);
            
            // æ£€æŸ¥æ˜¯å¦æ˜¯è®¤è¯é”™è¯¯(401)
            if (error.message === 'Authentication error' || error.type === 'UnauthorizedError') {
                console.log('è®¤è¯å¤±è´¥ï¼Œå°è¯•åˆ·æ–°token');
                try {
                    // åˆ·æ–°token
                    const authStore = useAuthStore.getState();
                    await authStore.refreshToken();
                    
                    // ä½¿ç”¨æ–°tokené‡æ–°è¿æ¥
                    const newToken = authStore.token;
                    if (newToken && socket) {
                        console.log('ä½¿ç”¨æ–°tokené‡æ–°è¿æ¥');
                        socket.auth = { token: newToken };
                        socket.connect();
                    }
                } catch (refreshError) {
                    console.error('Tokenåˆ·æ–°å¤±è´¥:', refreshError);
                    // å¼•å¯¼ç”¨æˆ·é‡æ–°ç™»å½•
                    get().addMessage({
                        id: uuidv4(),
                        type: 'error',
                        content: 'è®¤è¯å·²è¿‡æœŸï¼Œè¯·é‡æ–°ç™»å½•',
                        timestamp: new Date()
                    });
                }
            }
            
            set({ isConnected: false });
            get().handleReconnect();
        });

        // ... å…¶ä»–äº‹ä»¶ç›‘å¬å™¨ä¿æŒä¸å˜
    } catch (error) {
        console.error('Socket.IO åˆå§‹åŒ–é”™è¯¯:', error);
        set({ isConnected: false, socket: null });
    }
}
```

##### 2. ConversationHandler å®ä¾‹ç¼“å­˜ç®¡ç†

**ç”Ÿäº§çº§ç¼“å­˜ç­–ç•¥**ï¼š
```python
# æ”¹è¿› socketio_app.py çš„ Handler ç®¡ç†
from typing import Dict, Tuple
from contextlib import asynccontextmanager
import asyncio
from weakref import WeakSet

# Handler ç¼“å­˜ï¼š{(user_id, session_id): handler}
conversation_handlers: Dict[Tuple[str, str], ConversationHandler] = {}
handler_locks: Dict[Tuple[str, str], asyncio.Lock] = {}
active_handlers: WeakSet[ConversationHandler] = WeakSet()

@asynccontextmanager
async def get_conversation_handler(user_id: str, session_id: str, db_session, user):
    """çº¿ç¨‹å®‰å…¨çš„ Handler è·å–å’Œæ¸…ç†ç®¡ç†å™¨"""
    cache_key = (user_id, session_id)
    
    # è·å–æˆ–åˆ›å»ºé”
    if cache_key not in handler_locks:
        handler_locks[cache_key] = asyncio.Lock()
    
    async with handler_locks[cache_key]:
        # è·å–æˆ–åˆ›å»º Handler
        if cache_key not in conversation_handlers:
            handler = ConversationHandler(user_id, db_session, user)
            conversation_handlers[cache_key] = handler
            active_handlers.add(handler)
            logger.info(f"Created new handler for {cache_key}")
        else:
            handler = conversation_handlers[cache_key]
            logger.debug(f"Reusing existing handler for {cache_key}")
        
        try:
            yield handler
        finally:
            # åœ¨è¿™é‡Œå¯ä»¥æ·»åŠ æ¸…ç†é€»è¾‘ï¼Œå¦‚è¶…æ—¶æ¸…ç†ç­‰
            pass

# æ·»åŠ è¿æ¥æ–­å¼€æ—¶çš„Handleræ¸…ç†
@sio.event
async def disconnect(sid: str):
    """å®¢æˆ·ç«¯æ–­å¼€è¿æ¥äº‹ä»¶ - å¢å¼ºç‰ˆæ¸…ç†"""
    try:
        logger.info(f"Client disconnecting: {sid}")
        
        # è·å–ä¼šè¯ä¿¡æ¯
        session_info = active_sessions.get(sid, {})
        user_id = session_info.get('user_id')
        
        # æ¸…ç†ä¼šè¯ä¿¡æ¯
        if sid in active_sessions:
            session = active_sessions.pop(sid)
            duration = time() - session['connected_at']
            logger.info(f"Session ended for {sid}, duration: {duration:.2f}s")
        
        # æ£€æŸ¥æ˜¯å¦è¿˜æœ‰å…¶ä»–è¿æ¥ä½¿ç”¨åŒä¸€ç”¨æˆ·çš„Handler
        if user_id:
            user_has_other_connections = any(
                s.get('user_id') == user_id 
                for s in active_sessions.values()
            )
            
            # å¦‚æœç”¨æˆ·æ²¡æœ‰å…¶ä»–æ´»è·ƒè¿æ¥ï¼Œæ¸…ç†Handler
            if not user_has_other_connections:
                keys_to_remove = [
                    key for key in conversation_handlers.keys() 
                    if key[0] == str(user_id)
                ]
                for key in keys_to_remove:
                    handler = conversation_handlers.pop(key, None)
                    if handler:
                        logger.info(f"Cleaned up handler for {key}")
                
                # æ¸…ç†å¯¹åº”çš„é”
                for key in keys_to_remove:
                    handler_locks.pop(key, None)
        
        logger.info(f"Client disconnected: {sid}")
        
    except Exception as e:
        logger.error(f"Disconnect error for {sid}: {str(e)}")

@sio.event
async def user_message(sid: str, data: dict):
    """ä¼˜åŒ–åçš„ç”¨æˆ·æ¶ˆæ¯å¤„ç†å™¨"""
    session_info = active_sessions.get(sid, {})
    user = session_info.get('user')
    user_id = session_info.get('user_id')
    
    # è®¤è¯æ£€æŸ¥
    if not user or not user_id:
        await sio.emit('error', {
            'type': 'authentication_required',
            'message': 'è¯·å…ˆç™»å½•åå†å‘é€æ¶ˆæ¯',
            'timestamp': time()
        }, room=sid)
        return
    
    try:
        from .core.database import get_db
        db_session = next(get_db())
        
        message_content = data.get('content', '')
        session_id = data.get('session_id', 'default')
        
        # ä½¿ç”¨ä¸Šä¸‹æ–‡ç®¡ç†å™¨å®‰å…¨ç®¡ç† Handler
        async with get_conversation_handler(str(user_id), session_id, db_session, user) as handler:
            async for chunk in handler.stream_response(message_content, session_id):
                event_type = chunk.get('type', 'agent_response_chunk')
                await sio.emit(event_type, chunk, room=sid)
                
    except Exception as e:
        logger.error(f"Message handling error for {sid}: {str(e)}", 
                    user_id=user_id, session_id=session_id)
        await sio.emit('error', {
            'type': 'processing_error',
            'message': 'æ¶ˆæ¯å¤„ç†å‡ºé”™ï¼Œè¯·ç¨åé‡è¯•',
            'timestamp': time()
        }, room=sid)
    finally:
        # ç¡®ä¿æ•°æ®åº“ä¼šè¯å…³é—­
        if 'db_session' in locals():
            db_session.close()
```

##### 3. æ•°æ®åº“ä¼šè¯ç”Ÿå‘½å‘¨æœŸç®¡ç†

**æ”¹è¿›çš„æ•°æ®åº“ç®¡ç†**ï¼š
```python
from contextlib import asynccontextmanager
from sqlalchemy.orm import Session
from .core.database import SessionLocal

@asynccontextmanager
async def get_db_session() -> Session:
    """å¼‚æ­¥ä¸Šä¸‹æ–‡ç®¡ç†å™¨ï¼Œç¡®ä¿æ•°æ®åº“ä¼šè¯æ­£ç¡®å…³é—­"""
    db = SessionLocal()
    try:
        yield db
    except Exception as e:
        db.rollback()
        logger.error(f"Database session error: {str(e)}")
        raise
    finally:
        db.close()

# é‡æ„åçš„ user_message å¤„ç†å™¨
@sio.event
async def user_message(sid: str, data: dict):
    """å®Œæ•´çš„ç”¨æˆ·æ¶ˆæ¯å¤„ç†å™¨ï¼ŒåŒ…å«æ•°æ®åº“ä¼šè¯ç®¡ç†"""
    session_info = active_sessions.get(sid, {})
    user = session_info.get('user')
    user_id = session_info.get('user_id')
    
    if not user or not user_id:
        await sio.emit('error', {
            'type': 'authentication_required',
            'message': 'è¯·å…ˆç™»å½•åå†å‘é€æ¶ˆæ¯',
            'timestamp': time()
        }, room=sid)
        return
    
    message_content = data.get('content', '')
    session_id = data.get('session_id', 'default')
    
    try:
        # ä½¿ç”¨å¼‚æ­¥ä¸Šä¸‹æ–‡ç®¡ç†å™¨ç®¡ç†æ•°æ®åº“ä¼šè¯
        async with get_db_session() as db:
            async with get_conversation_handler(str(user_id), session_id, db, user) as handler:
                async for chunk in handler.stream_response(message_content, session_id):
                    event_type = chunk.get('type', 'agent_response_chunk')
                    await sio.emit(event_type, chunk, room=sid)
                    
    except Exception as e:
        logger.error(f"Message handling error for {sid}: {str(e)}", 
                    user_id=user_id, session_id=session_id)
        await sio.emit('error', {
            'type': 'processing_error',
            'message': 'æ¶ˆæ¯å¤„ç†å‡ºé”™ï¼Œè¯·ç¨åé‡è¯•',
            'error_details': str(e) if settings.environment == 'development' else None,
            'timestamp': time()
        }, room=sid)
```

##### 4. å‰ç«¯å®Œæ•´äº‹ä»¶ç›‘å¬

**å®Œå–„çš„å‰ç«¯äº‹ä»¶å¤„ç†**ï¼š
```typescript
// åœ¨ chatStore.ts ä¸­æ·»åŠ å®Œæ•´çš„æµå¼äº‹ä»¶ç›‘å¬
const setupStreamingEventListeners = (socket: Socket) => {
    // Agent å“åº”ç‰‡æ®µ
    socket.on('agent_response_chunk', (data) => {
        const { streamingMessageId, updateMessage, addMessage } = get();
        
        if (streamingMessageId && data.id === streamingMessageId) {
            // æ›´æ–°æµå¼æ¶ˆæ¯
            updateMessage(streamingMessageId, {
                content: data.content,
                timestamp: new Date(data.timestamp)
            });
        } else {
            // æ–°çš„æµå¼æ¶ˆæ¯
            const newMessage: ChatMessage = {
                id: data.id || uuidv4(),
                type: 'agent',
                content: data.content,
                timestamp: new Date(data.timestamp),
                isStreaming: true
            };
            addMessage(newMessage);
            set({ streamingMessageId: newMessage.id });
        }
    });

    // å·¥å…·è°ƒç”¨å¼€å§‹
    socket.on('tool_call_start', (data) => {
        const toolCall: ToolCall = {
            id: data.id,
            name: data.tool_name,
            args: data.tool_args,
            status: 'running',
            startTime: new Date(data.timestamp)
        };
        
        get().pendingToolCalls.set(data.id, toolCall);
        
        // æ˜¾ç¤ºå·¥å…·è°ƒç”¨çŠ¶æ€æ¶ˆæ¯
        get().addMessage({
            id: uuidv4(),
            type: 'system',
            content: `ğŸ”§ æ­£åœ¨æ‰§è¡Œï¼š${data.tool_name}`,
            timestamp: new Date(data.timestamp),
            toolCall
        });
    });

    // å·¥å…·è°ƒç”¨ç»“æœ
    socket.on('tool_call_result', (data) => {
        const { pendingToolCalls } = get();
        const toolCall = pendingToolCalls.get(data.id);
        
        if (toolCall) {
            toolCall.status = 'completed';
            toolCall.result = data.tool_result;
            toolCall.endTime = new Date(data.timestamp);
            
            // æ›´æ–°å·¥å…·è°ƒç”¨æ¶ˆæ¯
            get().addMessage({
                id: uuidv4(),
                type: 'system',
                content: `âœ… å·¥å…·æ‰§è¡Œå®Œæˆï¼š${toolCall.name}`,
                timestamp: new Date(data.timestamp),
                toolCall
            });
            
            pendingToolCalls.delete(data.id);
        }
    });

    // å·¥å…·è°ƒç”¨é”™è¯¯
    socket.on('tool_error', (data) => {
        const { pendingToolCalls } = get();
        const toolCall = pendingToolCalls.get(data.id);
        
        if (toolCall) {
            toolCall.status = 'error';
            toolCall.error = data.error;
            toolCall.endTime = new Date(data.timestamp);
            
            get().addMessage({
                id: uuidv4(),
                type: 'error',
                content: `âŒ å·¥å…·æ‰§è¡Œå¤±è´¥ï¼š${data.message}`,
                timestamp: new Date(data.timestamp),
                toolCall
            });
            
            pendingToolCalls.delete(data.id);
        }
    });

    // å¯¹è¯å®Œæˆ
    socket.on('conversation_complete', (data) => {
        const { streamingMessageId } = get();
        if (streamingMessageId) {
            updateMessage(streamingMessageId, { isStreaming: false });
            set({ streamingMessageId: null });
        }
    });
};

// åœ¨ connectWebSocket ä¸­è°ƒç”¨
// ... socket åˆ›å»ºå
setupStreamingEventListeners(socket);
```

##### 5. é”™è¯¯åˆ†ç±»å’Œå¤„ç†

**åç«¯é”™è¯¯åˆ†ç±»**ï¼š
```python
# å®šä¹‰é”™è¯¯ç±»å‹
class SocketErrorType:
    AUTHENTICATION_REQUIRED = "authentication_required"
    PROCESSING_ERROR = "processing_error"
    TOOL_ERROR = "tool_error"
    RATE_LIMIT = "rate_limit"
    VALIDATION_ERROR = "validation_error"

# ç»Ÿä¸€é”™è¯¯å‘é€å‡½æ•°
async def emit_error(sid: str, error_type: str, message: str, details: dict = None):
    """ç»Ÿä¸€çš„é”™è¯¯äº‹ä»¶å‘é€"""
    error_data = {
        'type': error_type,
        'message': message,
        'timestamp': time(),
        'session_id': sid
    }
    
    if details and settings.environment == 'development':
        error_data['details'] = details
    
    await sio.emit('error', error_data, room=sid)
    logger.error(f"Socket error for {sid}", error_type=error_type, message=message)
```

#### 3. ç°æœ‰äº‹ä»¶ç±»å‹å¤ç”¨

ConversationHandlerå·²ç»å®šä¹‰äº†å®Œæ•´çš„æµå¼äº‹ä»¶ç±»å‹ï¼š
- `agent_response_chunk`: Agentå“åº”ç‰‡æ®µ
- `tool_call_start`: å·¥å…·è°ƒç”¨å¼€å§‹  
- `tool_call_result`: å·¥å…·æ‰§è¡Œç»“æœ
- `tool_error`: å·¥å…·æ‰§è¡Œé”™è¯¯

**æ— éœ€é‡æ–°å®šä¹‰ï¼Œç›´æ¥ä½¿ç”¨ç°æœ‰å®ç°**

#### 6. å­ä»»åŠ¡æ‹†åˆ†æ–¹æ¡ˆ

åŸºäºä»¥ä¸Šè¯¦ç»†æŠ€æœ¯æ–¹æ¡ˆï¼Œå°†3-16-3æ‹†åˆ†ä¸ºä»¥ä¸‹å­ä»»åŠ¡ï¼š

**3-16-3-1ï¼šğŸ¯ é›†æˆConversationHandlerå®ç°çœŸæ­£AIå¯¹è¯**
- ä¿®æ”¹`socketio_app.py`çš„`user_message`äº‹ä»¶å¤„ç†å™¨
- é›†æˆç°æœ‰çš„`ConversationHandler.stream_response`æ–¹æ³•
- å®ç°åŸºæœ¬çš„AIå¯¹è¯åŠŸèƒ½ï¼ˆæš‚æ—¶è·³è¿‡è®¤è¯ï¼‰
- æµ‹è¯•åŸºæœ¬å¯¹è¯æµç¨‹

**3-16-3-2ï¼šğŸ¯ æ·»åŠ åŸºç¡€æµå¼äº‹ä»¶ç›‘å¬ï¼ˆå‰ç«¯ï¼‰**
- ä¿®æ”¹`chatStore.ts`æ·»åŠ æµå¼äº‹ä»¶ç›‘å¬å™¨
- æ”¯æŒ`agent_response_chunk`ã€`tool_call_start`ç­‰äº‹ä»¶
- å®ç°æµå¼æ¶ˆæ¯çŠ¶æ€ç®¡ç†
- æµ‹è¯•å‰åç«¯æµå¼é€šä¿¡

**3-16-3-3ï¼šğŸ”§ åº”ç”¨ç”Ÿäº§ç¯å¢ƒä¼˜åŒ–ï¼ˆè®¤è¯ã€ç¼“å­˜ã€DBç®¡ç†ï¼‰**
- å®ç°Socket.IOè¿æ¥è®¤è¯æœºåˆ¶
- æ·»åŠ ConversationHandlerå®ä¾‹ç¼“å­˜ç®¡ç†  
- å®ç°æ•°æ®åº“ä¼šè¯ç”Ÿå‘½å‘¨æœŸç®¡ç†
- æµ‹è¯•è®¤è¯å’Œç¼“å­˜åŠŸèƒ½

**3-16-3-4ï¼šğŸ”§ å®Œå–„é”™è¯¯åˆ†ç±»å’Œäº‹ä»¶ç›‘å¬**
- å®ç°ç»Ÿä¸€çš„é”™è¯¯åˆ†ç±»å’Œå¤„ç†
- å®Œå–„å‰ç«¯å®Œæ•´æµå¼äº‹ä»¶ç›‘å¬
- æ·»åŠ å·¥å…·è°ƒç”¨å¯è§†åŒ–
- æµ‹è¯•é”™è¯¯å¤„ç†å’Œå·¥å…·è°ƒç”¨

**3-16-3-5ï¼šğŸ”§ ç«¯åˆ°ç«¯æµ‹è¯•å’ŒéªŒè¯**
- ç«¯åˆ°ç«¯åŠŸèƒ½æµ‹è¯•
- æ€§èƒ½æµ‹è¯•å’Œä¼˜åŒ–
- å¹¶å‘è¿æ¥æµ‹è¯•
- å›å½’æµ‹è¯•éªŒè¯

#### 7. å®æ–½ä¼˜å…ˆçº§

**ä¼˜å…ˆçº§1ï¼ˆæ ¸å¿ƒåŠŸèƒ½ï¼‰**ï¼š
1. 3-16-3-1ï¼šé›†æˆConversationHandlerå®ç°AIå¯¹è¯
2. 3-16-3-2ï¼šå‰ç«¯åŸºç¡€æµå¼äº‹ä»¶ç›‘å¬

**ä¼˜å…ˆçº§2ï¼ˆç”Ÿäº§ä¼˜åŒ–ï¼‰**ï¼š
1. 3-16-3-3ï¼šè®¤è¯ã€ç¼“å­˜ã€DBç®¡ç†ä¼˜åŒ–
2. 3-16-3-4ï¼šé”™è¯¯å¤„ç†å’Œå®Œæ•´äº‹ä»¶ç›‘å¬

**ä¼˜å…ˆçº§3ï¼ˆæµ‹è¯•éªŒè¯ï¼‰**ï¼š
1. 3-16-3-5ï¼šç«¯åˆ°ç«¯æµ‹è¯•å’Œæ€§èƒ½éªŒè¯

### é£é™©è¯„ä¼°

**ä½é£é™©**ï¼š
- ConversationHandler é›†æˆï¼šç°æœ‰å®ç°å®Œå–„ï¼Œåªéœ€é€‚é…è°ƒç”¨æ–¹å¼
- è®¤è¯é›†æˆï¼šç°æœ‰è®¤è¯å‡½æ•°å¯ç›´æ¥ä½¿ç”¨

**ä¸­ç­‰é£é™©**ï¼š
- å‰ç«¯äº‹ä»¶ç›‘å¬ï¼šéœ€è¦å¤„ç†æµå¼æ¶ˆæ¯çš„çŠ¶æ€ç®¡ç†
- é”™è¯¯å¤„ç†ï¼šéœ€è¦ç¡®ä¿å¼‚å¸¸ä¸å½±å“å…¶ä»–ç”¨æˆ·

**ç¼“è§£ç­–ç•¥**ï¼š
1. åˆ†æ­¥å®æ–½ï¼Œæ¯æ­¥ç‹¬ç«‹æµ‹è¯•
2. ä¿ç•™ç°æœ‰åŠŸèƒ½ä½œä¸ºé™çº§æ–¹æ¡ˆ
3. å……åˆ†çš„é”™è¯¯å¤„ç†å’Œæ—¥å¿—è®°å½•

## Tests

### åŠŸèƒ½æµ‹è¯•ç­–ç•¥

**1. æ ¸å¿ƒåŠŸèƒ½æµ‹è¯•**
- Socket.IO è¿æ¥è®¤è¯æµ‹è¯•
- ConversationHandler é›†æˆæµ‹è¯•
- æµå¼å“åº”äº‹ä»¶æµ‹è¯•
- å·¥å…·è°ƒç”¨çŠ¶æ€å¹¿æ’­æµ‹è¯•

**2. é›†æˆæµ‹è¯•**
- ç«¯åˆ°ç«¯å¯¹è¯æµç¨‹æµ‹è¯•  
- ç”¨æˆ·è®¤è¯ä¸ä¼šè¯ç®¡ç†æµ‹è¯•
- Agent å®ä¾‹ç¼“å­˜æµ‹è¯•
- é”™è¯¯å¤„ç†å’Œæ¢å¤æµ‹è¯•

**3. å‰ç«¯é€‚é…æµ‹è¯•**
- æµå¼äº‹ä»¶ç›‘å¬æµ‹è¯•
- æ¶ˆæ¯çŠ¶æ€ç®¡ç†æµ‹è¯•
- å·¥å…·è°ƒç”¨å¯è§†åŒ–æµ‹è¯•
- é‡è¿æœºåˆ¶æµ‹è¯•

**4. æ€§èƒ½æµ‹è¯•**
- å“åº”æ—¶é—´åŸºå‡†æµ‹è¯•ï¼ˆç›®æ ‡ï¼šAgenté¦–å­—èŠ‚ < 2sï¼‰
- å¹¶å‘è¿æ¥æµ‹è¯•ï¼ˆç›®æ ‡ï¼šæ”¯æŒ10+ç”¨æˆ·ï¼‰
- å†…å­˜ä½¿ç”¨ç›‘æ§æµ‹è¯•
- é•¿æ—¶é—´è¿è¡Œç¨³å®šæ€§æµ‹è¯•

**5. å›å½’æµ‹è¯•**
- ç°æœ‰é‚®ä»¶åŒæ­¥åŠŸèƒ½éªŒè¯
- è®¤è¯ç³»ç»ŸåŠŸèƒ½éªŒè¯
- å…¶ä»–é¡µé¢åŠŸèƒ½éªŒè¯
- å‘åå…¼å®¹æ€§éªŒè¯

### æµ‹è¯•å®æ–½è®¡åˆ’

**é˜¶æ®µ1ï¼šå•å…ƒæµ‹è¯•**
- æ¯ä¸ªå­ä»»åŠ¡å®Œæˆåç«‹å³æµ‹è¯•
- ä½¿ç”¨ pytest + asyncio æ¡†æ¶
- æ¨¡æ‹Ÿç”¨æˆ·è¾“å…¥å’ŒAgentå“åº”

**é˜¶æ®µ2ï¼šé›†æˆæµ‹è¯•**  
- æ‰€æœ‰å­ä»»åŠ¡å®Œæˆåçš„ç³»ç»Ÿæµ‹è¯•
- ä½¿ç”¨çœŸå®çš„Socket.IOå®¢æˆ·ç«¯æµ‹è¯•
- éªŒè¯å®Œæ•´çš„å¯¹è¯æµç¨‹

**é˜¶æ®µ3ï¼šæ€§èƒ½æµ‹è¯•**
- ä½¿ç”¨ locust è¿›è¡Œè´Ÿè½½æµ‹è¯•
- ç›‘æ§ç³»ç»Ÿèµ„æºä½¿ç”¨
- éªŒè¯æ€§èƒ½æŒ‡æ ‡è¾¾æˆ

**é˜¶æ®µ4ï¼šç”¨æˆ·éªŒæ”¶æµ‹è¯•**
- æ‰‹åŠ¨ç«¯åˆ°ç«¯åŠŸèƒ½éªŒè¯
- ç”¨æˆ·ä½“éªŒæµ‹è¯•
- é”™è¯¯åœºæ™¯å¤„ç†éªŒè¯